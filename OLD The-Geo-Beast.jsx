/* * AEMap-TheBeast.jsx * Version 0.1 Alpha * An After Effetcs CS5 Dockable Scripts Panel for Equirectangular Map Creation * Copyright (c)  2012 Fabian "fabiantheblind" Morón Zirfas * Permission is hereby granted, free of charge, to any person obtaining a copy of this * software and associated documentation files (the "Software"), to deal in the Software * without restriction, including without limitation the rights to use, copy, modify, * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to * permit persons to whom the Software is furnished to do so, subject to the following * conditions: * The above copyright notice and this permission notice shall be included in all copies * or substantial portions of the Software. * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. * * see also http://www.opensource.org/licenses/mit-license.php * */// UI BUILD WITH http://crgreen.com/boethos/{  run_script(this);  function run_script(thisObj) {    // if (parseFloat(app.version) < 10.0) {    //   alert("This script works best in AE CS 5+.\nIt will work in CS4 but it is not realy tested.\nAll the names will be shortend to 27 letters to work in CS4");    //   // return;    // }    // this is some prechecking for the enclosed datafiles    // var path = ((new File($.fileName)).path);    // var testfile = File(path + "/world_geo_json/countries.geo.json");    // if (!testfile.exists) {    //   alert("The file \"GEOJson.geo.json\" does not exist or is not at the right place.\n" +     //     "it should be in a folder next to this script file like this: \"/world_geo_json/GEOJson.geo.json\".\n" +    //      "go to:\nhttp://github.com/fabiantheblind/AfterEffects-Javascript-World-Geo-Json\n" +    //      "and load the whole package");    //   return;    // }    // testfile = File( path+"/jsonfiles/World_nuclear_test_sites.json");    // if(!testfile.exists){    //        alert("The file \"World_nuclear_test_sites.json\" does not exist.\ngo to:\nhttp://github.com/fabiantheblind/AfterEffects-Javascript-World-Geo-Json\nand load the whole package");    //        return;    //     }    ///   THIS WILL CHECK IF PANEL IS DOCKABLE OR FLAOTING WINDOW      var win = buildUI(thisObj);    if ((win != null) && (win instanceof Window)) {      win.center();      win.show();    }  }  //  _    _ _____    _____ _      ____  ____          _       _____   // | |  | |_   _|  / ____| |    / __ \|  _ \   /\   | |     / ____|  // | |  | | | |   | |  __| |   | |  | | |_) | /  \  | |    | (___    // | |  | | | |   | | |_ | |   | |  | |  _ < / /\ \ | |     \___ \   // | |__| |_| |_  | |__| | |___| |__| | |_) / ____ \| |____ ____) |  //  \____/|_____|  \_____|______\____/|____/_/    \_\______|_____/   function buildUI(thisObj) {    var BEAST                     = "\"The Beast\"";    var DEBUG                     = true;    var ADDAEMAPMETA              = true;    var STROKE                    = false;    var ZORRO                     = true;    var THREEDEE                  = false;    var TIMESTAMP                 = true;    var PRECOMPOSE                = true;    var SINGLELAYER               = false;    var COMPNAME                  = "world map";    var USECURCMOP                = false;    var DUR                       = 23;    var FPS                       = 25;    var RANDOMCOLORS              = false;    var HSLCOLORS                 = false;    var SCALE                     = 3;    var RANGE                     = 360;    var ROFFSET                   = 0;    var SATURATION                = 55;    var LIGHTNESS                 = 66;    var BLACK                     = [0, 0, 0];    var WHITE                     = [1, 1, 1];    var GREY                      = [0.5, 0.5, 0.5];    var DARKGREY                  = [0.25, 0.25, 0.25];    var LIGHTGREY                 = [0.75, 0.75, 0.75];    var RED                       = [1, 0, 0];    var GREEN                     = [0, 1, 0];    var BLUE                      = [0, 0, 1];    var GUAVE                     = [0.95, 0.55, 0.50];    var SELECTEDCOLOR             = BLACK;    var THESELECTEDFILE           = "NOT SELECTED";    var FILESELECTED              = true;    var LAYERSETTINGS             = {      // have a look at the layer ddl strings      "pointType"                 : 0,      "lineStringType"            : 1,      "polygonType"               : 0,      "multiPolygonType"          : 0                                  };    var PLACETEXT                 = false;    var PLACEANIM                 = false;    var TEXTKEY                   = "name";    var ANIMKEY                   = "values";    var FEATURELENGTH             = 0;    // ------------ for help website call ------------    var winProgramFiles         = Folder.commonFiles.parent.fsName;    var winBrowserCmd           = winProgramFiles + "\\Internet Explorer\\iexplore.exe"; // You can chage the browser to use on windows here, use double slashes    var macBrowserCmdStart      = "osascript -e 'open location \"";    var macBrowserCmdEnd        = "\"'";        // ------------ UI Strings ------------    var version                 = 0.1;      var WEBSITE                 = "http://fabiantheblind.github.com/AEMap/";    var paneltitle              = "AE Map - " + BEAST +" " + version + " Alpha";    var numOfPrecomps           = 178;    var numOfPolygons           = 286;    var UIstr_SelFileDialog     = "Select a GeoJson file to import.";    var TOMANYFEATURES          = { "alertString": function(flen , WEBSITE){                                     var str = "Your Geo.json file has " + flen + " features.\n"+                                    "Maybe you should switch to \"plexus\" or \"form 2\". Checkout "+ WEBSITE +                                    " for more info on creating WAVEFRONT .obj files from Geo.json data." +                                     "\nyou still can work with that file. "+                                    "The performance on that many features depends on YOUR setup.\nBut dont worry - if something bad happens I wont say: \"I told you so!\"\n ;)";                                    return str} // end internal function                                  };// END TOMANYFEATURES    var REPORTFEATURESLENGTH    = {"alertString": function (flen){var str = "your Geo.json file has " + flen + " features."; return str}};    // ------------ ERROR STRINGS ------------    var HELPTEXT                = "Need help with " + paneltitle +                                 "? got to " + WEBSITE + " \n" +                                 "or read the readme file (that i will try to open now)\nUse the Options to customize your map. read the helptips";    var ERRORrof                = "please use only digits for the offset.\noffset is set to: ";    var ERRORrange              = "please use only digits for the range.\nrange is set to: ";    var ERRORscale              = "please use only digits for the scale." + "\n(e.g.: 3.55 thats near 1280" + "\nor just 1. thats 360x180)" + "\nscale is set to: ";    var ERRORsat                = "No no my friend - letters are no digits. please use only digits between 0 - 100 for the saturation.\nsaturation is set to: ";    var ERRORlghtn              = "Brighter than 100%?.please use only digits between 0 - 100 for the lightness.\nlightness is set to: ";    var ERRORname               = "oh-oh. There is no name for your comp.\ncomp name is set to: ";    var ERROR2big               = "autsch. your scale is bigger than 80. This results in a comp of 28800 pixels width.\nare you shure that is right?Use 10 for a 3600x1800 comp\nscale is set to: ";    var ERROR2small             = "ups. your scale is smaller than 0.1. THis will result in a comp of 36x18 pixels.\nare you shure that is right?Use 1 for a 360x180 comp\nscale is set to: ";    var ERRORreadmeexec         = "hm...the readme file is not there.\nwhat a shame\ndid i mention the website?\n" + WEBSITE;    var ERRORdur                = "please use only digits for the duration. like 10.25 or 1.0 .\nduration is set to: ";;    var ERROR2short             = "give it at least 0.1 man. Dont have a cow man! Shortening your comp is easy...";    var ERROR2long              = "After Effetcs cant handle comps longer than 3 hours.(I heard somewhere)\nduration is set to: ";    var ERRORscaleNotInt        = "BE AWARE!\n if your scale factor does not create integer values for the composition the script will floor the compsize."+                                  " (This is why this message appeared. If your scale fits i would not complain)\n"+                                  "The relations of the map are not affected.\nRight now your result will be:";    var ERRORnofileselected     = "You didn't select a GeoJson file. I will switch to the GEO Settings panel.";    var ERRORnofilefromdialog   = "You didnt select a file. ;(.\nplease try again";    var ERRORnogeomtry          = "Your geo data seems to have no proprty called geomtry. Please validate you GEO.Json file.";    var ERRORpathdisplayonly    = "This is only for display. Please use the button above to select a file.";    // ------------ Help TIP STRINGS ------------    var TIProffset              = "Define an offset for the hsl range.\nit starts with red at 0";    var TIPrange                = "Define an range for the hsl range.\n0 - 360 is one full range";    var TIPlght                 = "Define an lightness for the hsl range.\n0 - 100 works";    var TIPsat                  = "Define an saturation for the hsl range.\n0 - 100 works";    var TIPcpick                = "Selcet a preset color or use random or hsl colors\nthere are also themes. they just add some settings. Dont worry if it flips back to hsl colors";    var TIP3d                   = "Makes all the layers 3D and activates the continous rasterization";    var TIPtmstmp               = "Adds a unique timestamp to the name of the comp and the folder";    var TIPzorro                = "Add tags. Zorro Style!\n checkout Zorro - The Layer Tagger @ aescripts.com";    var TIPstroke               = "Adds a stroke effect to the polygon layers and a controller in the master comp. The uplink is via expression."+                                  "\nWARNING: lots of layers with a stroke effect and each with 6 expressions will need a lot of render power";    var TIPprcmp                = "If this is checked all the layers will be precomposed";    var TIPcmpnm                = "Enter a name for the comp";    var TIPscale                = "Enter a factor for the scale.\ne.g. 2.5 - 1 means 360x180. Do the math.\n maxium is 80 / min is 0.1";    var TIPdur                  = "Enter a value for the duration like 10.5 or 2.3 or one. Messured in seconds.";    var TIPsinglelyr            = "If checked all the mask will be created on one single layer.\n"+                                  "It will deactivate zorro tags and precompose!\n";    var TIPfpsddl               = "Select a framerate for your new comp";    var TIPpoint                = "Here you can select how point features will be drawn. If you use the basic marker it will be created for your comp.\n"+                                  "The selected layer feature can be dangerous.";    var TIPlinestring           = "Draw linestrings as masks or shapelayers. These paths/shapes wont be closed";    var TIPpolygon              = "Draw polygons as masks or shapelayers. These Paths will be closed";    var TIPmultipolygon         = "Draw polygons as masks or shapelayers. These Paths will be closed";    var TIPselectfile           = "Hit it and select a Geo.json file. \"The Beast\" will try to make a first check on your file."+                                  " Be patient. If you have a lot of features in your file it may take a moment";    var TIPpathdisplay          = "This field is for path display only!.\nTry to change the path in there. I dare you! Or are you chicken?\n"+                                  "bock bock booock. :D";    var TIPnamekey              = "if you enable this "+BEAST+ " will try to get all properties with the specified key from the Geo.json and place them as Textlayers."+                                  " This sounds difficult doesn't it? Read the online help or watch the tutorials on how this works.";    var TIPanimkey              = "if you enable this "+BEAST+ " will try to create a expression slider with all values defined in the Geo.Json with that specified key."+                                  " This sounds difficult doesn't it? Read the online help or watch the tutorials on how this works.";    var TIPanimkeyfield         = "Define a key for a properties with values to create a expression slider. Read the online help or watch the tutorials on how this works.";    var TIPnamekeyfield         = "Define a key for a properties with text values to create textlayers. Read the online help or watch the tutorials on how this works.";    var nl                      = "\n";    var delimit                 = "\n------------------------\n";    var QUICKTIPcompsettings    = "The settings for the newly created comp" +                                   "\n3D: "+ nl + TIP3d + "\n" + delimit +                                   "\nSingleLayer: "+ nl + TIPsinglelyr + "\n" +  delimit +                                  "\nTimeStamp: "+ nl + TIPtmstmp + "\n" +  delimit +                                  "\nAdd Stroke Effect: "+ nl + TIPstroke + "\n" +  delimit +                                  "\nZorro: "+ nl + TIPzorro + "\n" +  delimit +                                  "\nPrecomp: "+ nl + TIPprcmp + "\n" +  delimit +                                  "\n Go to this website " + WEBSITE + " for detailed info." ;    var QUICKTIPlayersettings   = "The settings for the new layers" +                                   "\nPoints: " + nl+ TIPpoint + "\n" +  delimit +                                  "\nLineStrings: "+ nl + TIPlinestring + "\n" +  delimit +                                  "\nPolygons: "+ nl + TIPpolygon + "\n" +  delimit +                                  "\nMultiPolygon: "+ nl + TIPmultipolygon + "\n" +  delimit +                                  "\n Go to this website " + WEBSITE + " for detailed info.";    var QUICKTIPcolorsettings   = "The settings for the colors" +                                   "\nDropDownList Color picker: "+ nl + TIPcpick + "\n" +  delimit +                                  "\nRange in degrees: " + nl+ TIPrange + "\n" +  delimit +                                  "\nOffset in degrees: " + nl+ TIProffset + "\n" +  delimit +                                  "\nSaturation in percent: "+ nl + TIPsat + "\n" +  delimit +                                  "\nLightness in percent: "+ nl + TIPlght + "\n" +  delimit +                                  "\n Go to this website " + WEBSITE + " for detailed info.";    var QUICKTIPgeosettings     = "The settings for the geo.json" +                                   "\nSelect file button: "+ nl + TIPselectfile + "\n" +  delimit +                                  "\nDisplay file path field:"+ nl + TIPpathdisplay + "\n" +  delimit +                                  "\nPlace Text Checkbox: " + nl+ TIPnamekey + "\n" +  delimit +                                  "\nPlace Animation Checkbox: "+ nl + TIPanimkey + "\n" +  delimit +                                  "\nText Place key: " + nl+ TIPnamekeyfield + "\n" +  delimit +                                  "\nAnimation Place key: "+ nl + TIPanimkeyfield + "\n" +  delimit +                                  "\n Go to this website " + WEBSITE + " for detailed info.";    var QUICKTIP                = QUICKTIPgeosettings;    // ------------ Panel selector DDL Strings ------------    var panelSelUIStrList       = ["Comp Settings",                                   "Layer Settings",                                   "Color Settings",                                   "GEOJson Settings"];    // ------------ Color Picker DDL STRINGS ------------    var colorsUIstrList = new Array();    colorsUIstrList.push("Black - [0,0,0] "); //0    colorsUIstrList.push("White - [1,1,1] "); //1    colorsUIstrList.push("Grey - [0.5,0.5,0.5] "); //2    colorsUIstrList.push("Light Grey - [0.75,0.75,0.75] "); //3    colorsUIstrList.push("Dark Grey - [0.25,0.25,0.25] "); //4    colorsUIstrList.push("Red - [1,0,0] "); //5    colorsUIstrList.push("Green - [0,1,0] "); //6    colorsUIstrList.push("Blue - [0,0,1] "); //7    colorsUIstrList.push("Guave - [0.95,0.55,0.50] (not only food! also a color)"); //8    // than comes a separator    colorsUIstrList.push("Random - (sets random colors)"); //10    // colorsUIstrList.push("HSL colors - (define a range and offset)"); //11    // colorsUIstrList.push("HSL Theme - lilac to red"); //12    // colorsUIstrList.push("HSL Theme - paleish greenish - sick ocean"); //13    // colorsUIstrList.push("HSL Theme - strong blue - wide"); //14    // colorsUIstrList.push("HSL Theme - strong red yellow green - pastafari baby!"); //15    // ------------ FPS Selector DDL Strings ------------    var fpsUIStrlist        = new Array(8, 12, 15, 23.976, 24, 25, 29.97, 30, 50, 69.94, 60);    var fpsUIStrlist_extend = new Array();    for (var i = 0; i < fpsUIStrlist.length; i++) {      fpsUIStrlist_extend.push(String(fpsUIStrlist[i]) + " fps");    };    // ------------ Point Type Selector DDL Strings ------------    var pointsUIStrlist = new Array();    pointsUIStrlist.push("nothing");    pointsUIStrlist.push("Basic Marker");    pointsUIStrlist.push("Null Object"); // implemeted    pointsUIStrlist.push("Light Layer"); // implemeted       pointsUIStrlist.push("selected layer");    pointsUIStrlist.push("Path");    pointsUIStrlist.push("Closed Path");    pointsUIStrlist.push("Shape Path");    pointsUIStrlist.push("Closed Shape Path");    // ------------ LineString Type Selector DDL Strings ------------    var linestringUIStrList = new Array();    linestringUIStrList.push("nothing");    linestringUIStrList.push("Path");    linestringUIStrList.push("Shape Path");    // ------------ Polygon Type Selector DDL Strings ------------    var polygonUIStrlist = new Array();    polygonUIStrlist.push("nothing");    polygonUIStrlist.push("Path");    polygonUIStrlist.push("Shape Path");    // ------------ MultiPolygon Type Selector DDL Strings ------------    var multipolygonUIStrlist = new Array();    multipolygonUIStrlist.push("nothing");    multipolygonUIStrlist.push("Path");    multipolygonUIStrlist.push("Shape Path");    //   _____ _____  ______       _______ ______   _______ _    _ ______   _    _ _____     //  / ____|  __ \|  ____|   /\|__   __|  ____| |__   __| |  | |  ____| | |  | |_   _|    // | |    | |__) | |__     /  \  | |  | |__       | |  | |__| | |__    | |  | | | |      // | |    |  _  /|  __|   / /\ \ | |  |  __|      | |  |  __  |  __|   | |  | | | |      // | |____| | \ \| |____ / ____ \| |  | |____     | |  | |  | | |____  | |__| |_| |_     //  \_____|_|  \_\______/_/    \_\_|  |______|    |_|  |_|  |_|______|  \____/|_____|    var win = (thisObj instanceof Panel) ? thisObj : new Window('palette', paneltitle, [260, 117, 550, 480]);    if (win != null) {      // ------------ The options the user can set ------------      // ------------ ui buttons ------------      win.versionlabel        = win.add('statictext',           [ 10,339,275,355], 'version ' + version + 'ALPHA');      win.drawmap             = win.add('button',               [ 10,309,216,335], 'UNLEASH THE BEAST!');      win.help                = win.add('button',               [222,309,275,335], 'Help?');      win.selector            = win.add('dropdownlist',         [ 50,  5,275, 25], panelSelUIStrList);      win.selector.selection  = 3;      win.quicktipbttn        = win.add('button',               [ 10,  5, 45, 25], '?');      // ------------ the panels ------------      var panelsize           =                                 [ 10, 30,275,250];      win.settingspanel       = win.add('panel', panelsize, '', { borderStyle: "etched" }); // COMPSETTINGSPANEL      win.settingspanel.visible = false;      win.layerspanel         = win.add('panel', panelsize, '', { borderStyle: "etched" }); // LAYERSTTINGSPANEL      win.layerspanel.visible = false;      win.colorspanel         = win.add('panel', panelsize, '', { borderStyle: "etched" }); // COLORSETTINGSPANEL      win.colorspanel.visible = false;      win.geopanel            = win.add('panel', panelsize, '', { borderStyle: "etched" }); // GEOSETTINGSPANEL      win.geopanel.visible    = true;      win.selector.onChange = function() {        // ------------ this is comp settings ------------        if (this.selection == 0) {          win.settingspanel.visible       = true;          win.layerspanel.visible         = false;          win.colorspanel.visible         = false;          win.geopanel.visible            = false;          QUICKTIP                        = QUICKTIPcompsettings;        };        // ------------ this is layer settings ------------        if (this.selection == 1) {          win.settingspanel.visible       = false;          win.layerspanel.visible         = true;          win.colorspanel.visible         = false;          win.geopanel.visible            = false;          QUICKTIP                        = QUICKTIPlayersettings;        };        // ------------ this is color settings ------------        if (this.selection == 2) {          win.settingspanel.visible       = false;          win.layerspanel.visible         = false;          win.colorspanel.visible         = true;          win.geopanel.visible            = false;          QUICKTIP                        = QUICKTIPcolorsettings;        };        // ------------ this is geo settings ------------        if (this.selection == 3) {          win.settingspanel.visible       = false;          win.layerspanel.visible         = false;          win.colorspanel.visible         = false;          win.geopanel.visible            = true;          QUICKTIP                        = QUICKTIPgeosettings;        };      }; // END SELECTOR ON CHANGE      // ------------ the comp settings UI------------      // win.threedee      = win.settingspanel.add('checkbox',              [  8, 10,138, 30], '3D?');      win.singlechbx    = win.settingspanel.add('checkbox',              [  8, 35,138, 55], 'Single Layer?');      // win.tmstmp        = win.settingspanel.add('checkbox',              [  8, 60,138, 80], 'Use Timestamp?');      win.addstroke     = win.settingspanel.add('checkbox',              [  8, 85,138,105], 'Add Stroke Effect?');      win.zorro         = win.settingspanel.add('checkbox',              [  8,110,138,130], 'Add Zorro Tags?');      // win.prcmpchbx     = win.settingspanel.add('checkbox',              [  8,135,138,155], 'Precompose?');      // win.currCompChbx  = win.settingspanel.add('checkbox',              [  8,160,138,180], 'Into Current Comp?');        win.compnamelabel = win.settingspanel.add('statictext',            [139, 5, 249, 30], '- Comp Name -');      win.compname      = win.settingspanel.add('edittext',              [139, 20,249, 50], 'world map');      win.scalefaclabel = win.settingspanel.add('statictext',            [139, 53,249, 70], '- Scale -');      win.scalefacval   = win.settingspanel.add('edittext',              [139, 70,249, 90], String(SCALE));      win.durlabel      = win.settingspanel.add('statictext',            [139, 93,249,110], '- Duration in Sec -');      win.durval        = win.settingspanel.add('edittext',              [139,110,249,130], String(DUR));      win.fpsddl        = win.settingspanel.add('dropdownlist',          [139,133,249,153], fpsUIStrlist_extend);      win.fpsddl.selection = 5;      // ------------ the color settings UI ------------      win.colorpicker   = win.colorspanel.add('dropdownlist',            [9, 8, 249, 30], colorsUIstrList);      win.colorpicker.add("separator", undefined, 9);                     // win.hslrangeval   = win.colorspanel.add('edittext',                [79, 37, 119, 59], String(RANGE));      // win.hslrangelabel = win.colorspanel.add('statictext',              [9, 38, 69, 58], 'Range in \u00B0:');      // win.roffsetval    = win.colorspanel.add('edittext',                [209, 37, 249, 59], String(ROFFSET));      // win.roffsetlabel  = win.colorspanel.add('statictext',              [139, 37, 199, 57], 'Offset in \u00B0:');                 // win.satlabel      = win.colorspanel.add('statictext',              [9, 68, 69, 88], 'Sat in %:');      // win.satval        = win.colorspanel.add('edittext',                [79, 67, 119, 89], String(SATURATION));      // win.lghtlabel     = win.colorspanel.add('statictext',              [139, 67, 199, 87], 'Light in %:');      // win.lghtnval      = win.colorspanel.add('edittext',                [209, 67, 249, 89], String(LIGHTNESS));                  // ------------ the layer settings UI ------------          win.pointTypeLabel            = win.layerspanel.add('statictext',  [9, 15, 138, 30], 'Draw Points as:----------');      win.lineStringLabel           = win.layerspanel.add('statictext',  [9, 40, 138, 55], 'Draw Lines as:----------');      win.pointTypeLabel            = win.layerspanel.add('statictext',  [9, 65, 138, 80], 'Draw Polygons as:----------');      win.pointTypeLabel            = win.layerspanel.add('statictext',  [9, 90, 138, 105], 'Draw MultiPolygons as:----------');              win.pointTypeSelecter         = win.layerspanel.add('dropdownlist',[139, 10, 249, 30], pointsUIStrlist);      win.linestringTypeSelecter    = win.layerspanel.add('dropdownlist',[139, 35, 249, 55], linestringUIStrList);      win.polygonTypeSelecter       = win.layerspanel.add('dropdownlist',[139, 60, 249, 80], polygonUIStrlist);      win.multipolygonTypeSelecter  = win.layerspanel.add('dropdownlist',[139, 85, 249, 105], multipolygonUIStrlist);    // var LAYERSETTINGS             = {    //   // have a look at the layer ddl strings    //   "pointType"                 : 0,    //   "lineStringType"            : 1,    //   "polygonType"               : 0,    //   "multiPolygonType"          : 0    //                               };      win.pointTypeSelecter.selection         = LAYERSETTINGS.pointType;      win.linestringTypeSelecter.selection    = LAYERSETTINGS.lineStringType;      win.polygonTypeSelecter.selection       = LAYERSETTINGS.polygonType;      win.multipolygonTypeSelecter.selection  = LAYERSETTINGS.multiPolygonType;      // ------------ the geojson settings UI ------------      win.selectGEOJson = win.geopanel.add('button',                     [  9,   8, 249,  30], 'Select a GeoJson File!');      win.GEOFilenamelabel = win.geopanel.add('edittext',                [  9,  35, 249, 110], THESELECTEDFILE, {        multiline: true                    });                    win.namekeylabel = win.geopanel.add('statictext',                  [  9, 120, 138, 135], 'Name Key:---------------');      win.animkeylabel = win.geopanel.add('statictext',                  [  9, 140, 138, 160], 'Animation Key:----------');      win.namekey = win.geopanel.add('edittext',                         [139, 115, 249, 135], TEXTKEY);      win.animkey = win.geopanel.add('edittext',                         [139, 140, 249, 160], ANIMKEY);      win.placeText = win.geopanel.add('checkbox',                       [  9, 165, 138, 185], 'Place Text');      win.placeAnim = win.geopanel.add('checkbox',                       [  9, 190, 138, 210], 'Place Animation');                     // ------------ Lots of UI properties ------------      // MASTER PANEL      win.versionlabel.justify          = 'right';      // ------------ color settings ------------      win.colorpicker.selection             = 0; // thats BLACK      // if single colors are selected          // win.roffsetval.enabled                = false;      // win.roffsetlabel.enabled              = false;      // win.hslrangeval.enabled               = false;      // win.hslrangelabel.enabled             = false;      // win.lghtnval.enabled                  = false;      // win.lghtlabel.enabled                 = false;      // win.satval.enabled                    = false;      // win.satlabel.enabled                  = false;      // COLOR SETTINGS STYLING         // win.hslrangeval.justify               = 'left';      // win.hslrangelabel.justify             = 'right';      // win.roffsetval.justify                = 'left';      // win.roffsetlabel.justify              = 'right';      // win.satval.justify                    = 'left';      // win.satlabel.justify                  = 'right';      // win.lghtnval.justify                  = 'left';      // win.lghtlabel.justify                 = 'right';          // // COLORSEETINGS HELPTIPS         // win.roffsetval.helpTip                = TIProffset;      // win.roffsetlabel.helpTip              = TIProffset;      // win.hslrangeval.helpTip               = TIPrange;      // win.hslrangelabel.visible             = TIPrange;      // win.lghtnval.helpTip                  = TIPlght;      // win.lghtlabel.helpTip                 = TIPlght;      // win.satval.helpTip                    = TIPsat;      // win.satlabel.helptips                 = TIPsat;      // win.colorpicker.helpTip               = TIPcpick;          // ------------ comp settings ----    --------      // CHECKBOX VALUES          // win.threedee.value                    = THREEDEE;      // win.tmstmp.value                      = TIMESTAMP;      win.zorro.value                       = ZORRO;      win.addstroke.value                   = STROKE;      // win.prcmpchbx.value                   = PRECOMPOSE;      win.singlechbx.value                  = SINGLELAYER;      // win.currCompChbx.value                = USECURCMOP;          // COMPSETTINGS HELPTIPS          // win.threedee.helpTip                  = TIP3d;      // win.tmstmp.helpTip                    = TIPtmstmp;      win.zorro.helpTip                     = TIPzorro;      win.addstroke.helptips                = TIPstroke;      // win.prcmpchbx.helpTip                 = TIPprcmp;      win.singlechbx.helpTip                = TIPsinglelyr;      win.compname.helpTip                  = TIPcmpnm;      win.compnamelabel.helpTip             = TIPcmpnm;      win.scalefacval.helpTip               = TIPscale;      win.scalefaclabel.helpTip             = TIPscale;      win.durval.helpTip                    = TIPdur;      win.durlabel.helpTip                  = TIPdur;      win.fpsddl.helpTip                    = TIPfpsddl;          //COMPSETTINGS STYLING          win.scalefacval.justify               = 'center';      win.scalefaclabel.justify             = 'center';      win.compname.justify                  = 'center';      win.compnamelabel.justify             = 'center';      win.durlabel.justify                  = 'center';      win.durval.justify                    = 'center';          // ------------ GEO settings -----    -------      win.placeAnim.value                   = PLACEANIM;      win.placeText.value                   = PLACETEXT;      win.selectGEOJson.helpTip             = TIPselectfile;      win.GEOFilenamelabel.helpTip          = TIPpathdisplay;      win.placeText.helpTip                 = TIPnamekey;      win.placeAnim.helpTip                 = TIPanimkey;      win.namekey.helpTip                   = TIPnamekeyfield;      win.animkey.helpTip                   = TIPanimkeyfield;          // GEOSETTINGS STYLING          win.namekeylabel.justify              = 'left';      win.namekey.justify                   = 'left';      win.namekey.enabled                   = false;      win.animkeylabel.justify              = 'left';      win.animkey.justify                   = 'left';      win.animkey.enabled                   = false;      // ------------ layer settings ------------      win.pointTypeSelecter.helpTip         = TIPpoint;      win.linestringTypeSelecter.helpTip    = TIPlinestring;      win.polygonTypeSelecter.helpTip       = TIPpolygon;      win.multipolygonTypeSelecter.helpTip  = TIPmultipolygon;      // ------------ the functions if user makes something on comp settings ------------      // win.threedee.onClick          = function() {  THREEDEE      = this.value; }; // 3D Cehckbox      // win.tmstmp.onClick            = function() {  TIMESTAMP     = this.value; }; // Timestamp checkbox      win.zorro.onClick             = function() {  ZORRO         = this.value; }; // zorro checkbox      win.addstroke.onClick         = function() {  STROKE        = this.value; }; // stroke checkbox      // win.prcmpchbx.onClick         = function() {  PRECOMPOSE    = this.value; }; // precomp checkbox      // win.currCompChbx.onClick      = function() {  USECURCMOP    = this.value; }; // current comp checkbox      win.singlechbx.onClick        = function() {        SINGLELAYER = this.value;        if (this.value == true) {          win.zorro.value           = false;          ZORRO                     = false;          win.zorro.enabled         = false;          win.prcmpchbx.value       = false;          PRECOMPOSE                = false;          win.prcmpchbx.enabled     = false;          win.colorpicker.selection = 0; // thats BLACK          SELECTEDCOLOR             = BLACK;          win.colorspanel.enabled   = false;        } else if (!this.value) {          win.prcmpchbx.enabled     = true;          win.zorro.enabled         = true;          SINGLELAYER               = false;          win.colorspanel.enabled   = true;        }      }; // single layer checkbox      // ------------ the scale textfield ------------      win.scalefacval.onChange = function() {        SCALE = Math.abs(parseFloat(this.text));        if (isNaN(SCALE) == true) {          SCALE             = 1;          this.text         = 1;          alert(ERRORscale  + SCALE);        }        if (SCALE < 0.1) {          SCALE             = 0.1;          this.text         = SCALE;          alert(ERROR2small + SCALE)        }        if (SCALE > 80) {          SCALE             = 80;          this.text         = SCALE;          alert(ERROR2big   + SCALE);        };        if ((checkFloat(SCALE) == true) && (checkFloat(SCALE * 360)) && (checkFloat(SCALE * 180))) {          alert(ERRORscaleNotInt + " w:" + String(SCALE * 360) + " h: " + String(SCALE * 180));        };      }; // end of scalefacval      // ------------ the duration textfield ------------      win.durval.onChange = function() {        DUR = Math.abs(parseFloat(this.text));        if (isNaN(DUR) == true) {          DUR               = 23;          this.text         = 23;          alert(ERRORdur    + DUR);        }        if (DUR < 0.1) {          DUR               = 0.1;          this.text         = DUR;          alert(ERROR2short + DUR)        }        if (DUR > 10800) {          DUR               = 10800;          this.text         = DUR;          alert(ERROR2long  + DUR)        };      };      // ------------ the color settings functions  ------------           // ------------ the range offset ------------//       win.roffsetval.onChange = function() {//         ROFFSET = Math.abs(parseInt(this.text));//         if (isNaN(ROFFSET) == true) {//           ROFFSET           = 0;//           this.text         = 0;//           alert(ERRORrof    + ROFFSET);//         }//       };//       // ------------ the range ------------//       win.hslrangeval.onChange = function() {//         RANGE = Math.abs(parseInt(this.text));//         if (isNaN(RANGE) == true) {//           RANGE             = 360;//           this.text         = 360;//           alert(ERRORrange + RANGE);//         }//       };//       // ------------ the saturation ------------//       win.satval.onChange = function() {//         SATURATION = Math.abs(parseInt(this.text));//         if (SATURATION > 100) {//           SATURATION      = 100;//           this.text       = SATURATION;//         }//         if (SATURATION < 0) {//           SATURATION      = 0;//           this.text       = SATURATION;//         }//         if (isNaN(SATURATION) == true) {//           SATURATION      = 55;//           this.text       = 55;//           alert(ERRORsat  + SATURATION);//         }//       };      // ------------ the lightness ------------//       win.lghtnval.onChange = function() {//         LIGHTNESS = Math.abs(parseInt(this.text));//         if (LIGHTNESS > 100) {//           LIGHTNESS = 100;//           this.text = LIGHTNESS;//         }//         if (LIGHTNESS < 0) {//           LIGHTNESS = 0;//           this.text = LIGHTNESS;//         }//         if (isNaN(LIGHTNESS) == true) {//           LIGHTNESS = 66;//           this.text = 66;//           alert(ERRORlghtn + LIGHTNESS);//         }//       };      // ------------ the comp name edittext ------------      win.compname.onChange = function() {        COMPNAME            = this.text;        COMPNAME            = shortenName(COMPNAME);        if (COMPNAME.length == 0) {          COMPNAME          = "world map";          this.text         = "world map";          alert(ERRORname   + COMPNAME);        }      };      win.fpsddl.onChange = function() {        for (var i in fpsUIStrlist) {          if (this.selection == i) {            FPS               = fpsUIStrlist[i];          };        };        // if (DEBUG) alert(FPS);      };      // ------------ the dropdown list for the colors ------------      win.colorpicker.onChange = function() {if (this.selection == 0) { SELECTEDCOLOR       = BLACK;};if (this.selection == 1) { SELECTEDCOLOR       = WHITE;};if (this.selection == 2) {  SELECTEDCOLOR       = GREY;};if (this.selection == 3) {  SELECTEDCOLOR       = LIGHTGREY;};if (this.selection == 4) {  SELECTEDCOLOR       = DARKGREY;};if (this.selection == 5) {  SELECTEDCOLOR       = RED;};if (this.selection == 6) {  SELECTEDCOLOR       = GREEN;};if (this.selection == 7) {  SELECTEDCOLOR       = BLUE;};if (this.selection == 8) {  SELECTEDCOLOR       = GUAVE;};if (this.selection == 10) {          SELECTEDCOLOR       = BLACK;          RANDOMCOLORS        = true;          HSLCOLORS           = false;        };        // if (this.selection == 11) {        //   HSLCOLORS                   = true;        //   RANDOMCOLORS                = false;        //   SELECTEDCOLOR               = BLACK;        //   win.roffsetval.enabled      = true;        //   win.roffsetlabel.enabled    = true;        //   win.hslrangeval.enabled     = true;        //   win.hslrangelabel.enabled   = true;        //   win.lghtnval.enabled        = true;        //   win.lghtlabel.enabled       = true;        //   win.satval.enabled          = true;        //   win.satlabel.enabled        = true;        // } else {        //   HSLCOLORS                   = false;        //   win.roffsetval.enabled      = false;        //   win.roffsetlabel.enabled    = false;        //   win.hslrangeval.enabled     = false;        //   win.hslrangelabel.enabled   = false;        //   win.lghtnval.enabled        = false;        //   win.lghtlabel.enabled       = false;        //   win.satval.enabled          = false;        //   win.satlabel.enabled        = false;        // };        // // ------------ these are the themes ------------        // // ------------ lilac to red ------------        // if (this.selection == 12) {        //   SELECTEDCOLOR               = BLACK;        //   HSLCOLORS                   = true;        //   RANDOMCOLORS                = false;        //   win.satval.text             = String (80);        //   SATURATION                  =         80;        //   win.lghtnval.text           = String (45);        //   LIGHTNESS                   =         45;        //   win.roffsetval.text         = String(300);        //   ROFFSET                     =        300;        //   win.hslrangeval.text        = String (60);        //   RANGE                       =         60;        //   this.selection              = 11;        // }        // // ------------ paleish greenish - sick ocean ------------        // if (this.selection == 13) {        //   SELECTEDCOLOR               = BLACK;        //   HSLCOLORS                   = true;        //   RANDOMCOLORS                = false;        //   win.satval.text             = String (23);        //   SATURATION                  =         23;        //   win.lghtnval.text           = String (66);        //   LIGHTNESS                   =         66;        //   win.roffsetval.text         = String(120);        //   ROFFSET                     =        120;        //   win.hslrangeval.text        = String (30);        //   RANGE                       =         30;        //   this.selection              = 11;        // }        // // ------------ strong blue - wide ------------        // if (this.selection == 14) {        //   SELECTEDCOLOR               = BLACK;        //   HSLCOLORS                   = true;        //   RANDOMCOLORS                = false;        //   win.satval.text             = String (90);        //   SATURATION                  =         90;        //   win.lghtnval.text           = String (45);        //   LIGHTNESS                   =         45;        //   win.roffsetval.text         = String(200);        //   ROFFSET                     =        200;        //   win.hslrangeval.text        = String (45);        //   RANGE                       =         45;        //   this.selection = 11;        // }        // // ------------ strong red yellow green - pastafari baby! ------------        // if (this.selection == 15) {        //   SELECTEDCOLOR               = BLACK;        //   HSLCOLORS                   = true;        //   RANDOMCOLORS                = false;        //   win.satval.text             = String (90);        //   SATURATION                  = 90;        //   win.lghtnval.text           = String (45);        //   LIGHTNESS                   = 45;        //   win.roffsetval.text         = String  (0);        //   ROFFSET                     = 0;        //   win.hslrangeval.text        = String(120);        //   RANGE                       = 120;        //   this.selection = 11;        // }      };      // ------------ the layer settings functions ------------      win.pointTypeSelecter.onChange        = function() {        LAYERSETTINGS.pointType             = Number(this.selection);        alert(LAYERSETTINGS.toSource());      };      win.linestringTypeSelecter.onChange   = function() {        LAYERSETTINGS.lineStringType        = Number(this.selection);        alert(LAYERSETTINGS.toSource());      };      win.polygonTypeSelecter.onChange      = function() {        LAYERSETTINGS.polygonType           = Number(this.selection);        alert(LAYERSETTINGS.toSource());      };      win.multipolygonTypeSelecter.onChange = function() {        LAYERSETTINGS.multiPolygonType      = Number(this.selection);        alert(LAYERSETTINGS.toSource());      };      // ------------ the geo settings functions ------------      win.selectGEOJson.onClick = function() {        var jsonfile = File.openDialog(UIstr_SelFileDialog, "*.json", false);        if (jsonfile != null) {          THESELECTEDFILE = jsonfile;          FILESELECTED = true;          win.GEOFilenamelabel.text = THESELECTEDFILE.fsName;          var testobj = readinGeoJSONFile(THESELECTEDFILE);          var FEATURELENGTH = inspectGeoJson(testobj);          if(FEATURELENGTH > 500){          alert( TOMANYFEATURES.alertString(FEATURELENGTH, WEBSITE));          }else{            alert(REPORTFEATURESLENGTH.alertString(FEATURELENGTH));          };          testobj = null;        } else {          FILESELECTED = false;          alert(ERRORnofilefromdialog);        };      };      win.GEOFilenamelabel.onChanging = function() {        alert(ERRORpathdisplayonly);        this.text = THESELECTEDFILE.fsName;      };      win.animkey.onChange = function() {ANIMKEY = this.text;};      win.namekey.onChange = function() {TEXTKEY = this.text;};      win.placeText.onClick = function() {        PLACETEXT = this.value;        if (this.value == true) {          win.namekey.enabled = true;        } else {          win.namekey.enabled = false;        };      };      win.placeAnim.onClick = function() {        PLACEANIM = this.value;        if (this.value == true) {          win.animkey.enabled = true;        } else {          win.animkey.enabled = false;        };      };      // ------------ the quick tip button ------------      win.quicktipbttn.onClick = function() {        alert(QUICKTIP);      };      // ------------ the help button ------------      win.help.onClick = function() {        alert(HELPTEXT);        openURL(WEBSITE, winBrowserCmd, macBrowserCmdStart, macBrowserCmdEnd);        // try{        // var path = ((new File($.fileName)).path);        // var testfile = File( path+"/readme_aemap.html");          // if(testfile.exists){testfile.execute();}else{alert(ERRORreadmeexec);}        //     }catch(e){}      };      // ------------ the draw the map button ------------      win.drawmap.onClick = function() {        //     alert("run the function");        if (FILESELECTED) {          Unleash_the_beast(USECURCMOP ,LAYERSETTINGS, THESELECTEDFILE, COMPNAME, ZORRO, STROKE, RANDOMCOLORS, THREEDEE, SCALE, RANGE, SATURATION, LIGHTNESS, ROFFSET, HSLCOLORS, SELECTEDCOLOR, TIMESTAMP, DUR, FPS, PRECOMPOSE, SINGLELAYER, PLACETEXT, PLACEANIM, TEXTKEY, ANIMKEY);        } else {          alert(ERRORnofileselected);          win.selector.selection = 3;          win.settingspanel.visible = false;          win.layerspanel.visible = false;          win.colorspanel.visible = false;          win.geopanel.visible = true;        }      };      //       win.layout.layout(true);      //       win.layout.resize();      //             //             //       win.onResizing = win.onResize = function () {      //         this.layout.resize();      //         }      //                   //       win.onShow = function (){      //         win.layout.layout();      //          win.minimumSize =win.preferredSize;      //         }    }    return win  }  //   _   _   _   _     _   _   _     _   _   _   _     //  / \ / \ / \ / \   / \ / \ / \   / \ / \ / \ / \    // ( D | R | A | W ) ( G | E | O ) ( J | O | S | N )   //  \_/ \_/ \_/ \_/   \_/ \_/ \_/   \_/ \_/ \_/ \_/                                                    // you could extract everything below this line to make it at oneshot script  //--------------------------------------------------------------------------  //    //  var compname = "world map";  //  var  zorro = true;  //  var  addstroke = false;  //  var  randomColors = false;  //  var  threedee = false;  //  var  factor = 1;  //  var  degrees = 20;  //  var  s  = 55;  //  var  l = 66;  //  var offset = 60;  //  var hslcolors = true;  //  var theColor = [1,1,1];  //  var tmstmp = true;  //  var dur = 23;  //  var fps = 25;  //  var precompose = true;  //  var onto_singlelayer = false;  //  var theselectedfile = "GEOJson.geo.json";  //  var  layersettingsObject = {"pointType":0, "lineStringType":0,"polygonType":0, "multiPolygonType":0};  // Unleash_the_beast(layersettingsObject, compname,zorro,addstroke,randomColors, threedee, factor,degrees, s,l, offset ,hslcolors, theColor,tmstmp,dur, precompose,onto_singlelayer,addText,addAnim,textKey,animKey);  function Unleash_the_beast( usecurrentcomp, layersettingsObject, theselectedfile, compname, zorro, addstroke, randomColors, threedee, factor, degrees, s, l, offset, hslcolors, theColor, tmstmp, dur, fps, precompose, onto_singlelayer, addText, addAnim, textKey, animKey) {    var startDate = new Date(); // this is for time recording    // Much better to pass thru :)    var ALLSettings = {      "selectedFile": theselectedfile,      "compname": compname,      "useCurrentComp": usecurrentcomp,       "zorro": zorro,      "addstroke": addstroke,      "randomColors": randomColors,      "threedee": threedee,      "factor": factor,      "degrees": degrees,      "saturation": s,      "lightness": l,      "offset": offset,      "hslcolors": hslcolors,      "selectedColor": theColor,      "timestamp": tmstmp,      "compDuration": dur,      "compFramrate": fps,      "precompose": precompose,      "onto_singlelayer": onto_singlelayer,      "theSingleLayer": null,      "GeoJsonObject": null,      "curComp": null,      "strokeControl": null,       "fullname": null,      "projectPrecompsFolder": null,      "timestampnumber": null,       "layersettings": layersettingsObject,      "addText": addText,      "addAnimation": addAnim,      "textKey": textKey,      "animationKey": animKey    };    app.beginUndoGroup("Unleash The Beast");    var scale = factor; // for rescaling the whole thing if it is 1.0    var cw = 360; //      var ch = 180;    // ------------ TIMESTAMP ------------    if (tmstmp) {      var timestamp = Number(new Date());      ALLSettings.timestampnumber = timestamp;      var fulllname = compname + "_" + ALLSettings.timestampnumber;    } else {      var fulllname = compname;    };    ALLSettings.fulllname = fulllname;    // ------------ make the comp or use the current ------------    if(ALLSettings.useCurrentComp ==true){    var curComp = app.project.activeItem;   if (!curComp || !(curComp instanceof CompItem)){        alert("Please select a Composition.");        return;    };        }else{    var curComp = app.project.items.addComp(shortenName(fulllname), Math.floor(cw * scale), Math.floor(ch * scale), 1, dur, fps);    };    ALLSettings.curComp = curComp;// ALLSettings filling the gaps    // ------------ addaemapmeta layer ------------    // this is a upcoming feature i think. or not. The Beast seams enough ;)    //     // if(ADDAEMAPMETA){    //   createMetaLayer(curComp,compname, zorro, addstroke,threedee,factor,degrees, s,l, offset ,hslcolors, theColor, tmstmp,dur,fps,precompose,onto_singlelayer);    // }    // ------------ Needs a folder if you precompose ------------    if (precompose) {      var GEOJsonFolder = app.project.items.addFolder(shortenName("GEOJson " + fulllname));      ALLSettings.projectPrecompsFolder = GEOJsonFolder; // ALLSettings filling the gaps    };    // ------------ reset view so we can see something ------------    // this is a workaround to make the created comp the frontmost comp    resetView(ALLSettings.curComp);    // ------------ if add stroke is selected ------------    if (addstroke) {    var ctrl = createStrokeController(ALLSettings.curComp, ALLSettings.zorro);    ALLSettings.strokeControl = ctrl;    };    // ------------ call the map drawing function ------------    // returns a list of used names and ids    ALLSettings.GeoJsonObject = readinGeoJSONFile(theselectedfile);    // ------------ this is the new thing much better  ------------    DRAWGEOJSON(ALLSettings);    // ------------ THIS IS THE OLD WAY WILL BE REMOVED ------------    // var list = drawMercatorMap(ALLSettings, curComp, GEOJsonFolder, ctrl, ALLSettings.GeoJsonObject, scale, zorro, addstroke, randomColors, threedee, theColor, degrees, s, l, offset, hslcolors, precompose, tmstmp, timestamp, onto_singlelayer);    // alert(list[0].toSource());    app.endUndoGroup();    // ------------ the final alert ------------    var endDate = new Date();    var timeTaken = endDate.getTime() - startDate.getTime();    alert("main function end\nlogging of after: " + timeTaken / 1000 + " seconds");  };  // ------------ map functions and utilities ------------  function inspectGeoJson(GeoJsonObject){    var features = GeoJsonObject.features;    var flen = features.length;    return flen;  };  function readinGeoJSONFile(THESELECTEDFILE) {    // var textFile = File.openDialog("Select a text file to import.", "*.*",false);    // var path = ((new File($.fileName)).path);    var textFile = THESELECTEDFILE; //;File( path+"/world_geo_json/" + THESELECTEDFILE);    if (textFile != null) {      var textLines = new Array();      textFile.open("r", "TEXT", "????");      while (!textFile.eof) {        textLines[textLines.length] = textFile.readln();      };      textFile.close();    };    if (!textLines) {      alert("there are no lines in your file or something went terribly wrong.");      return;    };    var str = textLines.join("");    var reg = new RegExp("\n|\r", "g");    str.replace(reg, " ");    // alert(str);    // normaly this should not use eval    // but i dont want to incorporate the JSON lib    var obj = eval("(" + str + ")"); // evaluate the JSON code    // if(obj === Object){alert("eval worked")}else{alert("eval error")};    return obj;  };  // ------------ UI & DEBUG functions ------------  function openURL(url, winBrowserCmd, macBrowserCmdStart, macBrowserCmdEnd) {    if ($.os.indexOf("Windows") != -1) {      system.callSystem("cmd /c \"" + winBrowserCmd + "\" " + url);    } else {      system.callSystem(macBrowserCmdStart + url + macBrowserCmdEnd);    };  };  // if AE is version CS 4 this will shorten all names to 27 characters  function shortenName(str) {    var res = "";    if (parseFloat(app.version) < 10.0) {      res = str.substr(0, 26);    } else {      res = str;    };    return res;  };  // check for float values  function checkFloat(val) {    var res = false;    var nulled = val - Math.floor(val);    if (nulled != 0) {      res = true;    } else {      res = false;    };    return res;  };  function resetView(curComp){    var duration = curComp.workAreaDuration;    curComp.workAreaDuration = (1 / curComp.frameRate) * 5; // ae needs at least 2 frames for previewing     curComp.ramPreviewTest(1.0, 1.0, 0); // i think this is where the CS4 Problems start     curComp.workAreaDuration = duration;    curComp.resolutionFactor = [4, 4];  };function createStrokeController(curComp, zorro){        // add a null object with some expression controllers      var ctrl = curComp.layers.addNull();      ctrl.name = "GEOJson control";      ctrl.source.name = "GEOJson control";      var color_ctrl = ctrl("ADBE Effect Parade").addProperty("ADBE Color Control");      color_ctrl.name = "stroke color";      color_ctrl("ADBE Color Control-0001").setValue([1, 1, 1, 1]);      var strokeWeight_ctrl = ctrl("ADBE Effect Parade").addProperty("ADBE Slider Control");      strokeWeight_ctrl.name = "stroke weight";      var brush_hardness_ctrl = ctrl("ADBE Effect Parade").addProperty("ADBE Slider Control");      brush_hardness_ctrl.name = "brush hardness";      var opacity_ctrl = ctrl("ADBE Effect Parade").addProperty("ADBE Slider Control");      opacity_ctrl.name = "stroke opacity";      var start_ctrl = ctrl("ADBE Effect Parade").addProperty("ADBE Slider Control");      start_ctrl.name = "stroke start";      var end_ctrl = ctrl("ADBE Effect Parade").addProperty("ADBE Slider Control");      end_ctrl.name = "stroke end";      var spaces_ctrl = ctrl("ADBE Effect Parade").addProperty("ADBE Slider Control");      spaces_ctrl.name = "stroke spaces";      if (zorro) {        ctrl.comment = "stroke control"      };      ctrl.locked = true; // this is to be shure that the controller stays in the world map comp      return ctrl;};  // function createMetaLayer(curComp, compname, zorro, addstroke,threedee,factor,degrees, s,l, offset ,hslcolors, theColor, tmstmp,dur,fps,precompose,onto_singlelayer){  // }  // _____  _____       __          __    _  _      _____ ______ ____      _  _     _____       _______         //|  __ \|  __ \     /\ \        / /  _| || |_   / ____|  ____/ __ \   _| || |_  |  __ \   /\|__   __|/\      //| |  | | |__) |   /  \ \  /\  / /  |_  __  _| | |  __| |__ | |  | | |_  __  _| | |  | | /  \  | |  /  \     //| |  | |  _  /   / /\ \ \/  \/ /    _| || |_  | | |_ |  __|| |  | |  _| || |_  | |  | |/ /\ \ | | / /\ \    //| |__| | | \ \  / ____ \  /\  /    |_  __  _| | |__| | |___| |__| | |_  __  _| | |__| / ____ \| |/ ____ \   //|_____/|_|  \_\/_/    \_\/  \/       |_||_|    \_____|______\____/    |_||_|   |_____/_/    \_\_/_/    \_\  // THIS IS THE BEAST    // var ALLSettings = {    //   "selectedFile": theselectedfile,    //   "compname": compname,    //   "zorro": zorro,    //   "addstroke": addstroke,    //   "randomColors": randomColors,    //   "threedee": threedee,    //   "factor": factor,    //   "degrees": degrees,    //   "saturation": s,    //   "lightness": l,    //   "offset": offset,    //   "hslcolors": hslcolors,    //   "selectedColor": theColor,    //   "timestamp": tmstmp,    //   "compDuration": dur,    //   "compFramrate": fps,    //   "precompose": precompose,    //   "onto_singlelayer": onto_singlelayer,    //   "theSingleLayer": null,    //   "GeoJsonObject": null,    //   "curComp": null,    //   "strokeControl": null,     //   "fullname": null,    //   "projectPrecompsFolder": null,    //   "timestampnumber": null,     //   "layersettings": layersettingsObject,    //   "addText": addText,    //   "addAnimation": addAnim,    //   "textKey": textKey,    //   "animationKey": animKey    // };  function DRAWGEOJSON(ALLSettings) {    var gmcoll = 0;    var report = new Array();    // try {    var features = ALLSettings.GeoJsonObject.features;    if(ALLSettings.onto_singlelayer){      ALLSettings.theSingleLayer =  ALLSettings.curComp.layers.addSolid(                                     ALLSettings.selectedColor ,                                     shortenName( ALLSettings.fullname ),                                    ALLSettings.curComp.width,                                    ALLSettings.curComp.height,                                    1,                                    ALLSettings.curComp.duration);    };    for (var i in features) {      var geomtry = features[i].geometry;      // alert(geomtry.toSource());      if (geomtry != null) {        var patternGC = "GeometryCollection";        regGC = new RegExp(patternGC);        var type = geomtry.type;        if (regGC.test(type) == true) {          alert("GM COLL");          var geometries = geomtry.geometries;          for (var j = 0; j < geometries.length; j++) {            getLocationsByType(ALLSettings, geometries[j],features[i] , i);          }          gmcoll++;        } else {          getLocationsByType(ALLSettings, geomtry, features[i], i);        }; // test for collection      }; // geomtry is not null    }; // end of i loop    // this should stay her at the end    // so you dont loose it    // report.push("File:\t" + this.path);          // report.push("GeometryCollection(s):\t"+this.gmcoll);    // report.push("----------------------");    // report.push("Point(s):\t"+ this.pnt );    // report.push("LineString(s):\t"+ this.ln);    // report.push("Polygon(s):\t"+ this.pol);    // report.push("MultiPolygon(s):\t"+ this.mpol);    // report.push("----------------------";    // report.push("Separate:\t"+this.separate);          // report.push("Scale:\t"+ this.factor);    // report.push("Comp size:\t"+(360 * this.factor) + " x " + (180 * this.factor));    // println(report);    // }/* END OF TRY */    // catch ( e) {     //   alert("Your GEOJson file seems corrupt. please doublecheck taht"+e);    // }  }  function getLocationsByType(ALLSettings, geomtry, feature, counter) {    var coords = null;    if (geomtry.hasOwnProperty("coordinates")) {      var coords = geomtry.coordinates;      var pnt  = 0;      var ln   = 0;      var pol  = 0;      var mpol = 0;      var type = geomtry.type;      var pattern = "";    // ------------ CHECK 4 POINTS ------------    if((ALLSettings.layersettings.pointType          != 0)){          pattern = "Point";          var regPnt = new RegExp(pattern, "g");          if (regPnt.test(type)    == true) {            pnt++;            getPointType(ALLSettings, coords, feature , type);          }; // end POINT}    };// end type 0 dont draw    // ------------ CHECK 4 LINSTRINGs ------------    if(ALLSettings.layersettings.lineStringType     !=0){          pattern = "LineString";          var regLn = new RegExp(pattern, "g");          if (regLn.test(type)     == true) {            ln++;            getLingStringType(ALLSettings, coords, feature, counter, type);          }; // end LINESTRING    };// end type 0 dont draw    // ------------ CHECK 4 POLYGON ------------    if(ALLSettings.layersettings.polygonType        !=0){          pattern = "Polygon";          var regPol = new RegExp(pattern, "g");          if (regPol.test(type)    == true)  {            pol++;            getPolygonType(ALLSettings, coords, type );          }; //end POLYGON    };// end type 0 dont draw    // ------------ CHECK 4 MULTIPOLYGON ------------    if( ALLSettings.layersettings.multiPolygonType  != 0){          pattern = "MultiPolygon";          var regMPol = new RegExp(pattern, "g");          if (regMPol.test(type)   == true) {            mpol++;            getMultiPolygonType(ALLSettings, coords, type);          }; //end MULTIPOLYGON      };// end type 0 dont draw    } else {      alert(ERRORnogeomtry);    };  };  //   _____ ______ _______   ______ ______       _______ _    _ _____  ______  _____   //  / ____|  ____|__   __| |  ____|  ____|   /\|__   __| |  | |  __ \|  ____|/ ____|  // | |  __| |__     | |    | |__  | |__     /  \  | |  | |  | | |__) | |__  | (___    // | | |_ |  __|    | |    |  __| |  __|   / /\ \ | |  | |  | |  _  /|  __|  \___ \   // | |__| | |____   | |    | |    | |____ / ____ \| |  | |__| | | \ \| |____ ____) |  //  \_____|______|  |_|    |_|    |______/_/    \_\_|   \____/|_|  \_\______|_____/                                                                                                                                                                         //  ______     __  _________     _______  ______   // |  _ \ \   / / |__   __\ \   / /  __ \|  ____|  // | |_) \ \_/ /     | |   \ \_/ /| |__) | |__     // |  _ < \   /      | |    \   / |  ___/|  __|    // | |_) | | |       | |     | |  | |    | |____   // |____/  |_|       |_|     |_|  |_|    |______|                                                                                                  function getPointType(ALLSettings, coords, feature, type) {    // try{    var x = 0;    var y = 0;    x = coords[0];    y = coords[1];    var pos = new Array(x, -y, 0);    drawPoints(ALLSettings, pos, feature);  };  function getLingStringType(ALLSettings, coords, feature, counter, type) {        var onePath = new Array();         loop_item(coords, onePath);    var compCoordsPath = world_coords_to_comp_coords(ALLSettings, onePath , type);        var newLayerObject  = drawPaths( ALLSettings , compCoordsPath  , counter, type, "LineString");  };  function getPolygonType(ALLSettings, coords, type) {            var onePath = new Array();     for (var l = 0; l < coords.length; l++) {      for (var k = 0; k < coords[l].length; k++) {        var x = coords[l][k][0];        var y = coords[l][k][1];        var pos = new Array(x, -y, 0);        onePath.push(new Array(x,y));      }; //end K    }; //end L        var compCoordsPath = world_coords_to_comp_coords(ALLSettings, onePath , type);        var newLayerObject  = drawPaths( ALLSettings , compCoordsPath  , 0, type , "polygon");  };  function getMultiPolygonType(ALLSettings, coords, type ) {    for (var j = 0; j < coords.length; j++) {      for (var n = 0; n < coords[j].length; n++) {        for (var k = 0; k < coords[j][n].length; k++) {          var x = coords[j][n][k][0];          var y = coords[j][n][k][1];          var pos = new Array(x, -y, 0);        }; // end K      }; // end N    }; // end J  };  //  _____  _____       __          _______ _   _  _____   // |  __ \|  __ \     /\ \        / /_   _| \ | |/ ____|  // | |  | | |__) |   /  \ \  /\  / /  | | |  \| | |  __   // | |  | |  _  /   / /\ \ \/  \/ /   | | | . ` | | |_ |  // | |__| | | \ \  / ____ \  /\  /   _| |_| |\  | |__| |  // |_____/|_|  \_\/_/    \_\/  \/   |_____|_| \_|\_____|                                                                                                                //     _   //    | |  //    | |  //    | |  //    | |  //    | |  //    | |  //    |_|  // __      __  // \ \    / /  //  \ \  / /   //   \ \/ /    //    \  /     //     \/                function loop_item(arr, onePath){    if( typeof arr[0] === 'number'){//             alert("X: "+ arr[0] + " Y " + arr[1]);            onePath.push([arr[0],arr[1]]);                    } else{                            for(var i =0;i< arr.length;i++){                      loop_item(arr[i],onePath);                    }            }        }function world_coords_to_comp_coords(ALLSettings, worldPath, type){  var layerTypeSetting  = whatLayerType (ALLSettings,type);  var compPath = new Array();    for (var ndx = 0; ndx < worldPath.length; ndx++){                var wcx = worldPath[ndx][0];        var wcy = worldPath[ndx][1];        var x = (( wcx* ALLSettings.factor) + (ALLSettings.curComp.width / 2));                // if(layerTypeSetting == 2){ x = x * ALLSettings.curComp.pixelAspect };        var y = (( wcy* ALLSettings.factor) - (ALLSettings.curComp.height / 2))*-1;//       alert("X: " +x +" Y: "+ y +" || WCX: "+wcx + " WCY: "+ wcy);      compPath.push([x,y]);    };  return compPath;};function whatLayerType (ALLSettings, type){    var layerTypeSetting = null;    var pat0 = "LineString";    var pat1 = "Polygon";    var pat2 = "MultiPolygon";    var reg0 = new RegExp(pat0,"g");    var reg1 = new RegExp(pat1,"g");    var reg2 = new RegExp(pat2,"g");     if(reg0.test(type)==true){    layerTypeSetting = ALLSettings.layersettings.lineStringType;    }else if(reg1.test(type)==true){    layerTypeSetting = ALLSettings.layersettings.polygonType;    }else if(reg2.test(type)==true){    layerTypeSetting = ALLSettings.layersettings.multiPolygonType;          } else {      alert("no type match");    };  return layerTypeSetting;};  function drawPaths(ALLSettings , path  , counter , type, name){    var layerTypeSetting = whatLayerType(ALLSettings, type);    var lname = name;//"NA  NOW";    if ((ALLSettings.timestamp ==true )&&(ALLSettings.onto_singlelayer == false)) {      lname = lname + "_" + ALLSettings.timestampnumber;    };    if (ALLSettings.onto_singlelayer) {      var layer = ALLSettings.theSingleLayer;    } else {      if(layerTypeSetting == 2){      var layer = ALLSettings.curComp.layers.addShape();      layer.name = shortenName(lname + " " + counter);      } else if(layerTypeSetting == 1){      var layer = ALLSettings.curComp.layers.addSolid(         ALLSettings.selectedColor ,         shortenName(lname + " " + counter),         ALLSettings.curComp.width,         ALLSettings.curComp.height,         1,         ALLSettings.curComp.duration);      }    };    addMask(ALLSettings, layer, path, false ,layerTypeSetting);    return layer;  };  function addMask(ALLSettings , layer , path , closed, layerTypeSetting){    // taken from http://www.redefinery.com/ae/fundamentals/masks/    // great resource    // given:    // layer = Layer object    //    if(layerTypeSetting == 2){    var masksGroup = layer.property("ADBE Root Vectors Group");    } else if(layerTypeSetting == 1){    var masksGroup = layer.property("ADBE Mask Parade"); // Get the PropertyGroup for the masks    };    // This PropertyGroup can also be retrieved by using     // layer.property("Masks") or layer.property("ADBE Mask Parade")    // Filter out layers that cannot use masks    if (masksGroup != null) {    if(layerTypeSetting == 2){    var mask = masksGroup.addProperty("ADBE Vector Shape - Group");    } else if(layerTypeSetting == 1){    var mask = masksGroup.addProperty("Mask"); // Create a new mask    };      // if (onto_singlelayer) {      //   mask.name = name + " " + counter      // };      if (mask != null) {        var s = new Shape(); // new shape object        if (s != null) {            // alert(path);          s.vertices = path; // put the path verticies into the shape          s.closed = closed; // The close attribute defaults to true            if(layerTypeSetting == 2){          var maskShape = mask.property("ADBE Vector Shape");          } else if(layerTypeSetting == 1){          var maskShape = mask.property("maskShape"); // Get the Mask Shape property for the mask          };                             maskShape.setValue(s); // Change the mask shape (not keyframed)                  // maskShape.setValue(s);          };        };      };  };  //  _____  _____       __          __  _____   ____ _____ _   _ _______ _____   // |  __ \|  __ \     /\ \        / / |  __ \ / __ \_   _| \ | |__   __/ ____|  // | |  | | |__) |   /  \ \  /\  / /  | |__) | |  | || | |  \| |  | | | (___    // | |  | |  _  /   / /\ \ \/  \/ /   |  ___/| |  | || | | . ` |  | |  \___ \   // | |__| | | \ \  / ____ \  /\  /    | |    | |__| || |_| |\  |  | |  ____) |  // |_____/|_|  \_\/_/    \_\/  \/     |_|     \____/_____|_| \_|  |_| |_____/                                                                                                                                                             // needs a return type for precompose  function drawPoints(ALLSettings, pos , feature){      var x = (pos[0]) * ALLSettings.factor + ( ALLSettings.curComp.width / 2);      var y = (pos[1]) * ALLSettings.factor + (ALLSettings.curComp.height / 2);      // if(ALLSettings.layersettings.pointType == 0 ){ alert("nothing to draw");};      if(ALLSettings.layersettings.pointType == 1 ){ alert(" "+pos);};  //  _   _ _    _ _      _        // | \ | | |  | | |    | |       // |  \| | |  | | |    | |       // | . ` | |  | | |    | |       // | |\  | |__| | |____| |____   // |_| \_|\____/|______|______|                                                                                                                                               if(ALLSettings.layersettings.pointType == 2 ){        var newLayerObject = ALLSettings.curComp.layers.addNull();            var nameKey = "name";            if(ALLSettings.addText == true ){              stdNameKey = ALLSettings.namekey;            };            if(ALLSettings.addAnim == true){              /* NOTHING TO DO RIGHT NOW */            };      // ------------ ZORRO AND NAME SETTING ------------         setPointLayerZorroAndName(ALLSettings,feature,nameKey, newLayerObject);       // ------------ 3D ------------            setPointLayerPosition(ALLSettings.threedee , newLayerObject , x ,y );      }; // END pointType 2 NULL OBJECT  //  _      _____ _____ _    _ _______ _____   // | |    |_   _/ ____| |  | |__   __/ ____|  // | |      | || |  __| |__| |  | | | (___    // | |      | || | |_ |  __  |  | |  \___ \   // | |____ _| || |__| | |  | |  | |  ____) |  // |______|_____\_____|_|  |_|  |_| |_____/                                                                                                                                              if(ALLSettings.layersettings.pointType == 3 ){        var n = getNameFromFeature(feature, nameKey);       var newLayerObject = ALLSettings.curComp.layers.addLight("Light " + n,[x,y]);      // if(parseFloat(app.version)>=10 ) {      // alert("you are using 10.5 AE");       // newLayerObject.lightType = lightType.POINT;      // };// dam a 10.5 feature that does not work?            setPointLayerZorroAndName(ALLSettings,feature,nameKey, newLayerObject);       // it needs this comment so you can sport them out and set them as pointlight      var buff = newLayerObject.comment;      newLayerObject.comment = "*LightLayer, " + buff;      setPointLayerPosition(ALLSettings.threedee , newLayerObject , x ,y );      alert("Lights"+ String(pos));      };// END POINTTYPE 3 LIGHTS  };function setPointLayerPosition(threedee, layer, x, y ){    // thanx redifinery http://www.redefinery.com/ae/fundamentals/layers/    if((threedee == true) || (layer instanceof LightLayer) ){      layer.position.setValue ([x,y,0]);      }else{      layer.position.setValue ([x,y]);    };};function setPointLayerZorroAndName( ALLSettings, feature, nameKey, layer){   if(feature.hasOwnProperty(nameKey)==true){     if(ALLSettings.zorro) layer.comment = feature.name;     layer.name = feature.name;     n =  feature.name;   };// maybee is not a valid geo   if(feature.hasOwnProperty('properties')){     if(feature.properties.hasOwnProperty(nameKey)==true){       if(ALLSettings.zorro) layer.comment = feature.properties.name;         layer.name = feature.properties.name;         n =feature.properties.name;     };// end properties name check   };// end check properties };function setLayerZorroAndName( ALLSettings, feature, layer){  var n = "";  try{   if(feature.hasOwnProperty('name')==true){     if(ALLSettings.zorro) layer.comment = feature.name;     layer.name = feature.name;     n =  feature.name;   };// maybee is not a valid geo   if(feature.hasOwnProperty('properties')){     if(feature.properties.hasOwnProperty('name')==true){       if(ALLSettings.zorro) layer.comment = feature.properties.name;         layer.name = feature.properties.name;         n = feature.properties.name;     };// end properties name check   };// end check properties}catch(e) {  writeLn(e) };   return n; };function getNameFromFeature(feature , nameKey ){  var n = "";  if(feature.hasOwnProperty(nameKey)==true){    n = feature.name;  };  if(feature.hasOwnProperty('properties')){     if(feature.properties.hasOwnProperty(nameKey)==true){    n = n + feature.properties.name;    };  };return n;};  //  _______ _    _ _____  _____   _____  _____   _      _____ _  ________   // |__   __| |  | |_   _|/ ____| |_   _|/ ____| | |    |_   _| |/ /  ____|  //    | |  | |__| | | | | (___     | | | (___   | |      | | | ' /| |__     //    | |  |  __  | | |  \___ \    | |  \___ \  | |      | | |  < |  __|    //    | |  | |  | |_| |_ ____) |  _| |_ ____) | | |____ _| |_| . \| |____   //    |_|  |_|  |_|_____|_____/  |_____|_____/  |______|_____|_|\_\______|                                                                           //  _      _____ _  ________   _____ _   _            ______ __  __          _____     ___  __   // | |    |_   _| |/ /  ____| |_   _| \ | |     /\   |  ____|  \/  |   /\   |  __ \   / _ \/_ |  // | |      | | | ' /| |__      | | |  \| |    /  \  | |__  | \  / |  /  \  | |__) | | | | || |  // | |      | | |  < |  __|     | | | . ` |   / /\ \ |  __| | |\/| | / /\ \ |  ___/  | | | || |  // | |____ _| |_| . \| |____   _| |_| |\  |  / ____ \| |____| |  | |/ ____ \| |      | |_| || |  // |______|_____|_|\_\______| |_____|_| \_| /_/    \_\______|_|  |_/_/    \_\_|       \___/ |_|                                                                                                                                                                                              //      _         _          _          _   //     | |       | |        | |        | |  //     | |       | |        | |        | |  //     | |       | |        | |        | |  //     | |       | |        | |        | |  //     | |       | |        | |        | |  //     | |       | |        | |        | |  //     |_|       |_|        |_|        |_|  // __      __ __      __ __      __ __      __  // \ \    / / \ \    / / \ \    / / \ \    / /  //  \ \  / /   \ \  / /   \ \  / /   \ \  / /   //   \ \/ /     \ \/ /     \ \/ /     \ \/ /    //    \  /       \  /       \  /       \  /     //     \/         \/         \/         \/                                                                                                //  _____  _____      __          __  _______ _    _ ______   __  __          _____    // |  __ \|  __ \    /\ \        / / |__   __| |  | |  ____| |  \/  |   /\   |  __ \   // | |  | | |__) |  /  \ \  /\  / /     | |  | |__| | |__    | \  / |  /  \  | |__) |  // | |  | |  _  /  / /\ \ \/  \/ /      | |  |  __  |  __|   | |\/| | / /\ \ |  ___/   // | |__| | | \ \ / ____ \  /\  /       | |  | |  | | |____  | |  | |/ ____ \| |       // |_____/|_|  \_|_/    \_\/  \/        |_|  |_|  |_|______| |_|  |_/_/    \_\_|       // with some hints from the fine jongware  // see http://forums.adobe.com/message/2538244#2538244  // draws the mercator map with some set arguments  function drawMercatorMap(ALLSettings, curComp, theFolder, countrieControl, GEOJson, scale, zorro, addstroke, randomColors, threedee, theColor, degrees, s, l, offset, hslcolors, precompose, tmstmp, timestamp, onto_singlelayer) {    // alert("end");    // return;    var list = new Array(); // this is the return value    // loop thur the GEOJson    // ------------ this is for single layers ------------    var slayer = null;    // var onto_singlelayer = true;    if (onto_singlelayer) {      slayer = curComp.layers.addSolid(theColor, shortenName("Solid_" + curComp.name), curComp.width, curComp.height, 1, curComp.duration);      if (addstroke) addStrokeEffect(curComp, slayer, countrieControl);    };    // ------------ this is the old way to draw the map look into  function DRAWGEOJSON (ALLSettings ) ------------    for (var i = 0; i < GEOJson.features.length; i++) {      // ------------ this works out the hsl colors ------------      if (hslcolors == true) {        theColor = colors_builder(GEOJson.features.length, degrees, s, l, offset, i);        if (onto_singlelayer) slayer.source.color = theColor;      };      // ------------ or random colors ------------      if (randomColors == true) {        theColor = [Math.random(), Math.random(), Math.random()];        if (onto_singlelayer) slayer.source.color = theColor;      };      // for better handling      var cnt = GEOJson.features[i];      var name = cnt.properties.name;      var type = cnt.geometry.type;      var coords = cnt.geometry.coordinates;      // push data in to the list taht gets returned      list.push({        "name": name,        "id": cnt.id,        "type": type      });      var counter = Number(i + 1);      writeLn("(" + (counter) + "/" + GEOJson.features.length + ") " + name);      // look for polygon or multipolygon      // if it is multipolygon we have to dig deeper to get the       // vertecies values      var pattern = "MultiPolygon";      var reg = new RegExp(pattern, "g");      var patternPol = "Polygon";      var regPol = new RegExp(patternPol, "g");      if (reg.test(type) == true) {        if (precompose) {          var list_of_layers = new Array();        }; // for precomposing the GEOJson        for (var j = 0; j < coords.length; j++) {          for (var k = 0; k < coords[j].length; k++) {            // finally draw a layer with a polygon            var layer = drawPolygon(ALLSettings ,curComp, countrieControl, coords[j][k], scale, cnt.id + "_" + name, zorro, addstroke, randomColors, threedee, theColor, tmstmp, timestamp, String(j), onto_singlelayer, slayer);            if (precompose) {              list_of_layers.push(layer);            }; // and store it          };        };        // now precompose all polygon objects from one countrie        if (precompose) {          precomper(list_of_layers, curComp, theFolder, cnt.id + "_" + name, name, zorro, threedee, tmstmp, timestamp);        };      } else if (regPol.test(type) == true) {        // we have only a polygon dont need the loop        if (precompose) {          var list_of_layers = new Array();        }; // for precompose        var layer = drawPolygon(ALLSettings, curComp, countrieControl, coords[0], scale, cnt.id + "_" + name, zorro, addstroke, randomColors, threedee, theColor, tmstmp, timestamp, "", onto_singlelayer, slayer);        if (precompose) {          list_of_layers.push(layer);          precomper(list_of_layers, curComp, theFolder, cnt.id + "_" + name, name, zorro, threedee, tmstmp, timestamp);        };      }; // close else    };    // done    return list;  };  // This draws actual one polygon object on the map  // and applys some expressions  function drawPolygon(ALLSettings, curComp, countrieControl, coords, scale, name, zorro, addstroke, randomColors, threedee, theColor, tmstmp, timestamp, counter, onto_singlelayer, slayer) {    // ------------ get the data ------------    var pt = new Array();    for (var i = 0; i < coords.length; i++) {      var x = (coords[i][0]) * scale + (curComp.width / 2);      var y = (coords[i][1] * -1) * scale + (curComp.height / 2);      pt.push([x, y]);    };    // create a new solid    // with random colors ore the preset coler that comes from above    var lname = name;    if (tmstmp) {      lname = lname + "_" + timestamp;    };    if (onto_singlelayer) {      var layer = slayer;    } else {      var layer = curComp.layers.addSolid(theColor, shortenName(lname + " " + counter), curComp.width, curComp.height, 1, curComp.duration);    };    if (zorro) {      layer.comment = "*" + name;    }; // if the user wishes comments    // and if he wishes 3d layers    if (threedee) {      layer.collapseTransformation = true;      layer.threeDLayer = true;    };    // taken from http://www.redefinery.com/ae/fundamentals/masks/    // great resource    // given:    // layer = Layer object    //    var masksGroup = layer("Masks"); // Get the PropertyGroup for the masks    // This PropertyGroup can also be retrieved by using     // layer.property("Masks") or layer.property("ADBE Mask Parade")    // Filter out layers that cannot use masks    if (masksGroup != null) {      var mask = masksGroup.addProperty("Mask"); // Create a new mask      if (onto_singlelayer) {        mask.name = name + " " + counter      };      if (mask != null) {        var s = new Shape(); // new shape object        if (s != null) {          s.vertices = pt; // put the path verticies into the shape          s.closed = true; // The close attribute defaults to true              maskShape = mask.property("maskShape"); // Get the Mask Shape property for the mask          maskShape.setValue(s); // Change the mask shape (not keyframed)        };      };      // if the user wishes strokes      if ((addstroke == true) ) {        addStrokeEffect(curComp, layer, countrieControl , onto_singlelayer);      }; // end addstroke      return layer;    };  };  //   _____ _______ _____   ____  _  ________   ______ ______ ______   //  / ____|__   __|  __ \ / __ \| |/ /  ____| |  ____|  ____|  ____|  // | (___    | |  | |__) | |  | | ' /| |__    | |__  | |__  | |__     //  \___ \   | |  |  _  /| |  | |  < |  __|   |  __| |  __| |  __|    //  ____) |  | |  | | \ \| |__| | . \| |____  | |____| |    | |       // |_____/   |_|  |_|  \_\\____/|_|\_\______| |______|_|    |_|                                                                                                                                             function addStrokeEffect(curComp, layer, countrieControl, onto_singlelayer) {    var stroke = layer("ADBE Effect Parade").addProperty("ADBE Stroke"); // add the effect    // add some expressions to control the strokes from the master comp with the stroke controler    app.beginSuppressDialogs(); // dont want any warnings    if (stroke.property("ADBE Stroke-0002").canSetExpression) {        stroke.property("ADBE Stroke-0002").expression = "comp(\"" + curComp.name + "\").layer(\"" + countrieControl.name         + "\").effect(\"stroke color\")(\"ADBE Color Control-0001\")"; // this is the color      if(onto_singlelayer == true){         stroke.property("ADBE Stroke-0002").expressionEnabled = false;         } else {          stroke.property("ADBE Stroke-0002").expressionEnabled = true;        } ;      };    if (stroke.property("ADBE Stroke-0003").canSetExpression) {      stroke.property("ADBE Stroke-0003").expression = "comp(\"" + curComp.name + "\").layer(\"" + countrieControl.name       + "\").effect(\"stroke weight\")(\"ADBE Slider Control-0001\")"; // this is the weight      if(onto_singlelayer == true) {        stroke.property("ADBE Stroke-0003").expressionEnabled = false;    } else {      stroke.property("ADBE Stroke-0003").expressionEnabled = true;      };    };    if (stroke.property("ADBE Stroke-0004").canSetExpression) {      stroke.property("ADBE Stroke-0004").expression = "comp(\"" + curComp.name + "\").layer(\"" + countrieControl.name       + "\").effect(\"brush hardness\")(\"ADBE Slider Control-0001\")"; // this is the Brush Hardness      if(onto_singlelayer == true){        stroke.property("ADBE Stroke-0004").expressionEnabled = false;    } else {       stroke.property("ADBE Stroke-0004").expressionEnabled = true;      };    };    if (stroke.property("ADBE Stroke-0005").canSetExpression) {      stroke.property("ADBE Stroke-0005").expression = "comp(\"" + curComp.name + "\").layer(\"" + countrieControl.name       + "\").effect(\"stroke opacity\")(\"ADBE Slider Control-0001\")"; // this is the Brush Hardness      if(onto_singlelayer == true) {        stroke.property("ADBE Stroke-0005").expressionEnabled = false;    } else  {      stroke.property("ADBE Stroke-0005").expressionEnabled = true;      };    };    if (stroke.property("ADBE Stroke-0008").canSetExpression) {      stroke.property("ADBE Stroke-0008").expression = "comp(\"" + curComp.name + "\").layer(\"" + countrieControl.name       + "\").effect(\"stroke start\")(\"ADBE Slider Control-0001\")"; // this is the Brush Hardness      if(onto_singlelayer == true){        stroke.property("ADBE Stroke-0008").expressionEnabled = false;     } else {      stroke.property("ADBE Stroke-0008").expressionEnabled = true ;      };    };    if (stroke.property("ADBE Stroke-0009").canSetExpression) {      stroke.property("ADBE Stroke-0009").expression = "comp(\"" + curComp.name + "\").layer(\"" + countrieControl.name       + "\").effect(\"stroke end\")(\"ADBE Slider Control-0001\")"; // this is the Brush Hardness      if(onto_singlelayer == true){        stroke.property("ADBE Stroke-0009").expressionEnabled = false;    } else  {      stroke.property("ADBE Stroke-0009").expressionEnabled = true;      };    };    if (stroke.property("ADBE Stroke-0006").canSetExpression) {      stroke.property("ADBE Stroke-0006").expression = "comp(\"" + curComp.name + "\").layer(\"" + countrieControl.name       + "\").effect(\"stroke spaces\")(\"ADBE Slider Control-0001\")"; // this is the Brush Hardness      if(onto_singlelayer == true){        stroke.property("ADBE Stroke-0006").expressionEnabled = false;    } else{       stroke.property("ADBE Stroke-0006").expressionEnabled = true;      };    };    app.endSuppressDialogs(false);  };  //   _____  _____  ______  _____  ____  __  __ _____ _____ _   _  _____   //  |  __ \|  __ \|  ____|/ ____|/ __ \|  \/  |  __ \_   _| \ | |/ ____|  //  | |__) | |__) | |__  | |    | |  | | \  / | |__) || | |  \| | |  __   //  |  ___/|  _  /|  __| | |    | |  | | |\/| |  ___/ | | | . ` | | |_ |  //  | |    | | \ \| |____| |____| |__| | |  | | |    _| |_| |\  | |__| |  //  |_|    |_|  \_\______|\_____|\____/|_|  |_|_|   |_____|_| \_|\_____|  //                                                                        function precomper(arrOLayers, curComp, thefolder, name, comment, zorro, threedee, tmstmp, timestamp) {    var layerIndices = new Array(); // precompose takes layer inidcies    // loop thru a list of layer    for (var l in arrOLayers) {      // and push their index into an array      layerIndices[layerIndices.length] = arrOLayers[l].index;    };    var lname = name;    if (tmstmp) {      lname = lname + "_" + timestamp;    };    // now precompose the result           var newComp = curComp.layers.precompose(layerIndices, shortenName(lname), true);    // it is the selected layer    var preCompedLayer = curComp.selectedLayers[0];    // make it also 3D    if (threedee) {      preCompedLayer.collapseTransformation = true;      preCompedLayer.threeDLayer = true;    };    // and add comments    if (zorro) {      preCompedLayer.comment = "*" + comment    };    newComp.parentFolder = thefolder; // houskeeping the project    // }catch(e){alert(e);}  };  //    _____  ____  _       ____  _____   _____   //   / ____|/ __ \| |     / __ \|  __ \ / ____|  //  | |    | |  | | |    | |  | | |__) | (___    //  | |    | |  | | |    | |  | |  _  / \___ \   //  | |____| |__| | |____| |__| | | \ \ ____) |  //   \_____|\____/|______|\____/|_|  \_\_____/   //                                               // ------------ color creation ------------  // builds colors based on input   function colors_builder(len, degrees, s, l, offset, step) {    var hue = (offset + ((degrees / (len + 1)) * step)) % 360;    var rgb = color_hsl2rgb(hue, s, l);    var colRGB = new Array();    colRGB[0] = rgb.r;    colRGB[1] = rgb.g;    colRGB[2] = rgb.b;    // AE needs values betweeon 0 and 1    // the values returned are between 0 and 255    var r = colRGB[0] / 255;    var g = colRGB[1] / 255;    var b = colRGB[2] / 255;    return [r, g, b];  }  // ------------ this is some wired stuff i dont realy understand but it works ------------  // color converiosn found here  // http://www.codingforums.com/showthread.php?t=11156  function color_hsl2rgb(h, s, l) {    var m1, m2, hue;    var r, g, b    s /= 100;    l /= 100;    if (s == 0) r = g = b = (l * 255);    else {      if (l <= 0.5) m2 = l * (s + 1);      else m2 = l + s - l * s;      m1 = l * 2 - m2;      hue = h / 360;      r = color_HueToRgb(m1, m2, hue + 1 / 3);      g = color_HueToRgb(m1, m2, hue);      b = color_HueToRgb(m1, m2, hue - 1 / 3);    };    return {      r: r,      g: g,      b: b    };  };  function color_HueToRgb(m1, m2, hue) {    var v;    if (hue < 0) hue += 1;    else if (hue > 1) hue -= 1;    if (6 * hue < 1) v = m1 + (m2 - m1) * hue * 6;    else if (2 * hue < 1) v = m2;    else if (3 * hue < 2) v = m1 + (m2 - m1) * (2 / 3 - hue) * 6;    else v = m1;    return 255 * v;  };  // ------------ end of wired stuff i dont realy understand ------------}