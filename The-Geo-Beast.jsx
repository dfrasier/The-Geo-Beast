	//  _______ _    _ ______ 	// |__   __| |  | |  ____|	//    | |  | |__| | |__   	//    | |  |  __  |  __|  	//    | |  | |  | | |____ 	//    |_|  |_|  |_|______|	                       	                       	//   _____ ______ ____  	//  / ____|  ____/ __ \ 	// | |  __| |__ | |  | |	// | | |_ |  __|| |  | |	// | |__| | |___| |__| |	//  \_____|______\____/ 	                     	                     	//  ____  ______           _____ _______ 	// |  _ \|  ____|   /\    / ____|__   __|	// | |_) | |__     /  \  | (___    | |   	// |  _ <|  __|   / /\ \  \___ \   | |   	// | |_) | |____ / ____ \ ____) |  | |   	// |____/|______/_/    \_\_____/   |_|   	                                      		// Copyright (c)  2012 	// Fabian "fabiantheblind" Morón Zirfas  	// Permission is hereby granted, free of charge, to any 	// person obtaining a copy of this software and associated	// documentation files (the "Software"), to deal in the Software	// without restriction, including without limitation the rights 	// to use, copy, modify, merge, publish, distribute, sublicense,	// and/or sell copies of the Software, and to  permit persons to 	// whom the Software is furnished to do so, subject to 	// the following conditions:  	// The above copyright notice and this permission notice	// shall be included in all copies or substantial portions of the Software.  	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,	// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES	// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.	// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF  CONTRACT,	// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTIO	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  		// see also http://www.opensource.org/licenses/mit-license.php	{ // ------------ the global error strings ------------  var errorStrings = {    "nocoordinates"   : "there is no property 'coordinates' in the geometry",    "nogeometry"      : "there is no property geometry",    "notype"          : "there is no property 'type' in the geometry",    "nofile"          : "the file is null. Try again",    "nogeojson"       : "the geo json is not valid",    "featureisolation": "The isolation of the geo json features went wrong",    "compcreation"    : "There was an error while creating the comp"   };mainScript();function mainScript(){	app.beginUndoGroup("Unleash The Geo Beast");	// this will hold all settings and be created by the UI	var meta = {		"ch" : 180,		"cw" : 360,		"factor" : 3,		"dur" : 10,		"fps" : 25,		"curComp" : null,		"do3d" : true,    "doSinglelayer": true,    "theSLayer":null,    "theSLayerPoly": null,    "theSLayerMultiPoly": null,    "theSLayerLineString" : null,    "nameKey": 'name', 		"file": null, 		"GEOJSONObject" : null,		"GeoObjectsList" 		: null,		"doPoints" 		: true,		"pointLayerType"		: 2,		"doLines" 		: true,		"lineLayerType"			: 1,		"doPolygons" 		: true,		"polygonLayerType"		: 0, 		"doMultiPolygons" 	: true,		"multiPolygonLayerType" 	: 0,    "doStroke": true,    "doFill" : true,    "fillColor": [1,1,1],    "strokeColor":[0,0,0]   	};  // read in the filemeta.file = selectJsonFile();if(meta.file == null){ alert(errorStrings.nofile); return;};	// read in GEO Datameta.GEOJSONObject = readinGeoJSONFile(meta.file);if(meta.GEOJSONObject == null) {  alert(errorStrings.nogeojson);  return;};	// now split it for better handling// the result is an JSON object that has points LineStrings and so onmeta.GeoObjectsList = isolateTypes(meta);if(meta.GeoObjectsList == null){  alert(errorStrings.featureisolation);  return; };	// now make the new compmeta.curComp = app.project.items.addComp(					shortenName("new comp"), 					(meta.cw * meta.factor), 					(meta.ch * meta.factor), 					1,/*aspect ratio*/					meta.dur, 					meta.fps);if(meta.curComp == null){  alert(errorStrings.compcreation);  return;};  // bring it to the frontresetView(meta.curComp);  //  _____   ____ _____ _   _ _______ _____   // |  __ \ / __ \_   _| \ | |__   __/ ____|  // | |__) | |  | || | |  \| |  | | | (___    // |  ___/| |  | || | | . ` |  | |  \___ \   // | |    | |__| || |_| |\  |  | |  ____) |  // |_|     \____/_____|_| \_|  |_| |_____/                                                                                     // build the pointsif((meta.doPoints == true)&& (meta.GeoObjectsList.points.length>0)){  drawPoints(meta);}; //end of doPointsif((meta.doLines==true) && (meta.GeoObjectsList.lineStrings.length > 0)){  drawLineStrings(meta);}; // end of doLinesif((meta.doPolygons==true)&&(meta.GeoObjectsList.polygons.length > 0)){  drawPolygons(meta);}; // end of doPolygons/** *  THIS IS NOT TESTED YET! *   */ if((meta.doMultiPolygons==true) && (meta.GeoObjectsList.multiPolygons.length > 0)){  drawMultiPolygons(meta);}; // end of doMultiPolygons    app.endUndoGroup();};/** *  this prepares a layer for adding a path *  it works for lineStrings,polygons and multipolygons */ function prepareLayerAndAddPath(meta, geojsonObject, name ,closePath, featureType, coordinates,layer){var newLSLayer = null;if(meta.doSinglelayer != true){  if(meta.lineLayerType == 0){   newLSLayer = meta.curComp.layers.addSolid(                [1,1,1],                name ,                 meta.curComp.width, meta.curComp.height, 1,                 meta.curComp.duration);  }else if(meta.lineLayerType == 1 ){   newLSLayer = meta.curComp.layers.addShape();    newLSLayer.name = name;        newLSLayer.anchorPoint.setValue([meta.curComp.width/2,meta.curComp.height/2]);  };}else if (meta.doSinglelayer==true){newLSLayer = layer;};  // alert(lineString.toSource());  // featureType 0 adds a fill featureType 1 adds a stroke  addPath(meta, newLSLayer, coordinates, closePath, name, featureType);};// ------------ end of prepareLayerAndAddPath ------------/** * adds a path to a layer  * parts taken from http://www.redefinery.com/ae/fundamentals/masks/ * great resource * edited to use also shapelayers */ function addPath(meta, layer, path ,closePath, name ,type){  // alert(path.toSource());	pt = new Array();	for(var j =0; j < path.length;j++){		var x = (path[j][0])* meta.factor + (meta.curComp.width/2);		var y = (path[j][1]* -1)* meta.factor + (meta.curComp.height/2);    // in here the bounding box should be calculated		pt.push([x,y]);	}; // close coords loop	var masksGroup = null;if( layer instanceof ShapeLayer ){  masksGroup = layer("ADBE Root Vectors Group"); // Get the PropertyGroup for the shape//~   if(meta.doSinglelayer == true){//~     masksGroup = masksGroup.addProperty("ADBE Vector Group");//~   };  }else {  masksGroup = layer("ADBE Mask Parade"); // Get the PropertyGroup for the masks};if (masksGroup != null){  var mask = null;  var shapeGroup = null;  if(layer instanceof ShapeLayer){    mask = masksGroup.addProperty("ADBE Vector Shape - Group");  }else {    mask = masksGroup.addProperty("ADBE Mask Atom");       // Create a new mask  };    if (mask != null){      mask.name = name;    var s = new Shape();// new shape object    if (s != null){            s.vertices = pt;                        // put the path verticies into the shape            s.closed = closePath;                        // The close attribute defaults to true             if(layer instanceof ShapeLayer){            maskShape = mask.property("ADBE Vector Shape");            }else {               maskShape = mask.property("ADBE Mask Shape");  // Get the Mask Shape property for the mask            };            maskShape.setValue(s);                   // Change the mask shape (not keyframed)        };    };	// if(layer instanceof ShapeLayer){	// 	if(type == 0){	// 		var fill = masksGroup.addProperty("ADBE Vector Graphic - Fill");	//     		fill.property("ADBE Vector Fill Color").setValue([0,0,0]);	//     		fill.name = "fill";	// 	}else{	// 		var stroke = masksGroup.addProperty("ADBE Vector Graphic - Stroke");	// 			stroke.property( "ADBE Vector Stroke Color").setValue([0,0,0]); //  				stroke.name = "stroke";	// 	};	// };};};/** *  This should write Multipolygons *  Not Tested yet *   */ function drawMultiPolygons (meta) {        if(meta.doSinglelayer==true){      meta.theSLayerMultiPoly = meta.curComp.layers.addShape();      meta.theSLayerMultiPoly.name = "AllGeoObjectsMultiPolygon";      meta.theSLayerMultiPoly.anchorPoint.setValue([meta.curComp.width/2,meta.curComp.height/2])    }; // end of doSinglelayer  var closePath = true;  var featureType = 0;  for(var j = 0; j < meta.GeoObjectsList.multiPolygons.length;j++){        var name = meta.GeoObjectsList.multiPolygons[j].name;        if(name.length < 1){          name = "MultiPolygon " + j;        };        var closePath = true;        alert(meta.GeoObjectsList.multiPolygons[j].coordinates[0].toSource);        prepareLayerAndAddPath(                meta,                 meta.GeoObjectsList.multiPolygons[j],                name ,                closePath, 0 ,                meta.GeoObjectsList.multiPolygons[j].coordinates[0],                meta.theSLayerMultiPoly                );      };  //end of i loop lineStrings};/** *  this draws the polygons *   */ function drawPolygons(meta){      if(meta.doSinglelayer==true){      meta.theSLayerPoly = meta.curComp.layers.addShape();      meta.theSLayerPoly.name = "AllGeoObjectsPolygon";      meta.theSLayerPoly.anchorPoint.setValue([meta.curComp.width/2,meta.curComp.height/2])    }; // end of doSinglelayer  var closePath = true;  var featureType = 0;  for(var j = 0; j < meta.GeoObjectsList.polygons.length;j++){        var name = meta.GeoObjectsList.polygons[j].name;        if(name.length < 1){          name = "Polygon " + j;        };// end of namecheck        var closePath = true;        prepareLayerAndAddPath(                meta,                 meta.GeoObjectsList.polygons[j],                name ,                closePath, 0 ,                meta.GeoObjectsList.polygons[j].coordinates[0],                meta.theSLayerPoly                );      };  //end of j loop polygons    if(meta.doSinglelayer == true){      // we add stroke and fill      if(meta.theSLayerPoly instanceof ShapeLayer){        if(meta.doStroke == true){          var stroke = meta.theSLayerPoly("ADBE Root Vectors Group").addProperty("ADBE Vector Graphic - Stroke");          stroke.property("ADBE Vector Stroke Color").setValue(meta.strokeColor);          stroke.name = "stroke";          };// end of doStroke          if(meta.doFill == true){          var fill = meta.theSLayerPoly("ADBE Root Vectors Group").addProperty("ADBE Vector Graphic - Fill");          fill.property("ADBE Vector Fill Color").setValue(meta.fillColor);          fill.name = "fill";          };// end of doFill        };// end of shapelayercheck    }; // end of single layer stroke creation};/** *  This draws linestrings *   */ function drawLineStrings(meta){//if we put them onto one single layer we can refactor the whole thing// this means we can create a GEO Object and than fit it to the comp  if(meta.doSinglelayer==true){    meta.theSLayerLineString = meta.curComp.layers.addShape();    meta.theSLayerLineString.name = "AllGeoObjectsLineString";    meta.theSLayerLineString.anchorPoint.setValue([meta.curComp.width/2,meta.curComp.height/2])  }; // end of doSinglelayerfor(var i = 0; i < meta.GeoObjectsList.lineStrings.length;i++){    var name = meta.GeoObjectsList.lineStrings[i].name;    if(name.length < 1){        name = "LineString " + i;    };    // drawLineStrings(meta, meta.GeoObjectsList.lineStrings[i], name);    var closePath = false;    prepareLayerAndAddPath(            meta,            meta.GeoObjectsList.lineStrings[i],            name,            closePath, 1,            meta.GeoObjectsList.lineStrings[i].coordinates,            meta.theSLayerLineString            );  };  //end of i loop lineStrings  if(meta.doSinglelayer==true){    // we add a stroke and no fill    if(meta.theSLayerLineString instanceof ShapeLayer){      var stroke = meta.theSLayerLineString("ADBE Root Vectors Group").addProperty("ADBE Vector Graphic - Stroke");      stroke.name = "stroke";    };  }; // end of single layer stroke creation};/** *  This draws points *   */ // function drawPoints(meta, point , name ){//   var position = point.coordinates;//  var x = (position[0]) * meta.factor + ( meta.curComp.width / 2);//  var y = (position[1]) * meta.factor + ( meta.curComp.height / 2);// var newLayer =  null;// if(meta.pointLayerType == 0){// 	newLayer = meta.curComp.layers.addSolid([1,1,1], name , 50, 50, 1, meta.curComp.duration);// } else if (meta.pointLayerType == 1 ){// 	newLayer = meta.curComp.layers.addLight(name,[x,y]);// }else if(meta.pointLayerType == 2 ){// 	newLayer = meta.curComp.layers.addText(name);// };// if(meta.do3d == true){// 	newLayer.threeDLayer = true;// };// if(meta.pointLayerType != 1){ // 	setLayerPosition(meta.do3d , newLayer ,x,y);// };// };function drawPoints(meta) {  for(var i = 0; i < meta.GeoObjectsList.points.length;i++){    var name = meta.GeoObjectsList.points[i].name;    if(name.length < 1){      name = "Point " + i;    };    var point = meta.GeoObjectsList.points[i];    var position = point.coordinates;    var x = (position[0]) * meta.factor + ( meta.curComp.width / 2);    var y = (position[1]) * meta.factor + ( meta.curComp.height / 2);    var newLayer =  null;    if(meta.pointLayerType == 0){      newLayer = meta.curComp.layers.addSolid([1,1,1], name , 50, 50, 1, meta.curComp.duration);    } else if (meta.pointLayerType == 1 ){      newLayer = meta.curComp.layers.addLight(name,[x,y]);    }else if(meta.pointLayerType == 2 ){      newLayer = meta.curComp.layers.addText(name);    };    if(meta.do3d == true){      newLayer.threeDLayer = true;    };    if(meta.pointLayerType != 1){       setLayerPosition(meta.do3d , newLayer ,x,y);    };  };// end of i loop points};function setLayerPosition(do3d, layer, x, y ){    // thanx redifinery http://www.redefinery.com/ae/fundamentals/layers/    if((do3d == true) || (layer instanceof LightLayer) ){      layer.position.setValue ([x,y,0]);      }else{      layer.position.setValue ([x,y]);    };};// ------------ utilities ------------  function shortenName(str) {    var res = "";    if (parseFloat(app.version) < 10.0) {      res = str.substr(0, 26);    } else {      res = str;    };    return res;  };/** *  this resets the view  * */   function resetView(comp){    var duration = comp.workAreaDuration;    comp.workAreaDuration = (1 / comp.frameRate) * 5; // ae needs at least 2 frames for previewing     comp.ramPreviewTest(1.0, 1.0, 0); // i think this is where the CS4 Problems start     comp.workAreaDuration = duration;    comp.resolutionFactor = [4, 4];  };// ------------ FILE HANDLING ------------function selectJsonFile(){        var jsonfile = File.openDialog("Select a jsonfile", "*.json", false);        if (jsonfile != null) {         return jsonfile;        } else {          // alert("Error file is null");		      return null;        };};  function readinGeoJSONFile(theFile) {    // var textFile = File.openDialog("Select a text file to import.", "*.*",false);    // var path = ((new File($.fileName)).path);    var textFile = theFile; //;File( path+"/world_geo_json/" + THESELECTEDFILE);    if (textFile != null) {      var textLines = new Array();      textFile.open("r", "TEXT", "????");      while (!textFile.eof) {        textLines[textLines.length] = textFile.readln();      };      textFile.close();    };    if (!textLines) {      alert("there are no lines in your file or something went terribly wrong.");      return;    };    var str = textLines.join("");    var reg = new RegExp("\n|\r", "g");    str.replace(reg, " ");    // alert(str);    // normaly this should not use eval    // but i dont want to incorporate the JSON lib    var obj = eval("(" + str + ")"); // evaluate the JSON code    // if(obj === Object){alert("eval worked")}else{alert("eval error")};    return obj;  };// ------------ end of file handling ------------function isolateTypes(meta){	// var GEOJSONObject = meta.GEOJSONObject;	var features = meta.GEOJSONObject.features;      var GeoObjectsList = {      		"points": [],      		"lineStrings" :[],      		"polygons" : [],      		"multiPolygons": []       };    for (var i in features) {      var geometry = features[i].geometry;      // alert(geometry.toSource());      if (geometry != null) {        var patternGC = "GeometryCollection";        regGC = new RegExp(patternGC);        var type = geometry.type;        if (regGC.test(type) == true) {          	// alert("GM COLL");          	var geometries = geometry.geometries;          	for (var j = 0; j < geometries.length; j++) {            getLocationsByType(meta,features[i],meta.nameKey, geometries[j], GeoObjectsList);          }; // close J LOOP        /* CLOSE REG TEST FOR GMCollection */         } else {        // this is simple geometry no geometry collection         getLocationsByType(meta,features[i],meta.nameKey, geometry,  GeoObjectsList);        }; // test for collection      }else{      	alert("geometry == null");      }; // geometry is not null    }; // end of i loopreturn GeoObjectsList;};/** * this function separates the features from the GEOJson * for better handling  * it also finds a property by a defined key *    arguments: * meta is the mta master object * feature is one object * nameKey is the string to look for in the properties * geometry is the features gemotry *    return: * it just sets some data into the meta object * there is no return */   function getLocationsByType(meta,feature, nameKey, geometry , GeoObjectList) {    var coords = null;    /**      * first we check for a property that holds our text     * this is pretty cool because the user can define a key     * and the function selects by that key     * the trick is the for key in feature     * key is than the name not a number     * have a look at this stackoverflow     * http://stackoverflow.com/questions/4222596/json-get-key-names-as-text     *      */         var name = "";    if (feature.hasOwnProperty('properties')) {      if(feature.properties.hasOwnProperty(nameKey)){        for(var key in feature.properties){            pattern = nameKey;          var regKey = new RegExp(pattern, "g");          if (regKey.test(key)     == true) {            name = feature.properties[key];          };        };              };    }; // end of feature.hasOwnProperty('properties') // ------------ now lets dig for coordinates ------------    if (geometry.hasOwnProperty("coordinates")) {      if(geometry.hasOwnProperty("type")){           var type = geometry.type;           var pattern = "";        if(geometry.hasOwnProperty("coordinates")){          coords = geometry.coordinates;        // ------------ CHECK 4 POINTS ------------          if((meta.doPoints)){                  pattern = "Point";              var regPnt = new RegExp(pattern, "g");              if (regPnt.test(type)    == true) {                GeoObjectList.points.push({"name":name ,"coordinates":coords});                  }; // end POINT}        };// end of checkForPoints dont draw            // ------------ CHECK 4 LINSTRINGs ------------        if(meta.doLines){              pattern = "LineString";              var regLn = new RegExp(pattern, "g");              if (regLn.test(type)     == true) {                GeoObjectList.lineStrings.push({"name":name ,"coordinates":coords});                  }; // end LINESTRING        };// end of checkForLines dont draw            // ------------ CHECK 4 POLYGON ------------        if(meta.doPolygons){              pattern = "Polygon";              var regPol = new RegExp(pattern, "g");              if (regPol.test(type)    == true)  {                GeoObjectList.polygons.push({"name":name ,"coordinates":coords});                  }; //end POLYGON        };// end end of ckeckForPolys dont draw            // ------------ CHECK 4 MULTIPOLYGON ------------        if( meta.doMultiPolygons){              pattern = "MultiPolygon";              var regMPol = new RegExp(pattern, "g");              if (regMPol.test(type)   == true) {                    GeoObjectList.multiPolygons.push({"name":name ,"coordinates":coords});              }; //end MULTIPOLYGON          };// end endOfCheckForMultiPolys dont draw          }else{            alert(errorStrings.notype);          };                }else{          alert(errorStrings.nocoordinates);        };      } else {      alert(errorStrings.nogeometry);    };    };  //END SCRIPT}