	//  _______ _    _ ______ 	// |__   __| |  | |  ____|	//    | |  | |__| | |__   	//    | |  |  __  |  __|  	//    | |  | |  | | |____ 	//    |_|  |_|  |_|______|	                       	                       	//   _____ ______ ____  	//  / ____|  ____/ __ \ 	// | |  __| |__ | |  | |	// | | |_ |  __|| |  | |	// | |__| | |___| |__| |	//  \_____|______\____/ 	                     	                     	//  ____  ______           _____ _______ 	// |  _ \|  ____|   /\    / ____|__   __|	// | |_) | |__     /  \  | (___    | |   	// |  _ <|  __|   / /\ \  \___ \   | |   	// | |_) | |____ / ____ \ ____) |  | |   	// |____/|______/_/    \_\_____/   |_|   	                                      		// Copyright (c)  2012 	// Fabian "fabiantheblind" Morón Zirfas  	// Permission is hereby granted, free of charge, to any 	// person obtaining a copy of this software and associated	// documentation files (the "Software"), to deal in the Software	// without restriction, including without limitation the rights 	// to use, copy and modify the Software, and to permit persons to 	// whom the Software is furnished to do so, subject to 	// the following conditions:  	// The above copyright notice and this permission notice	// shall be included in all copies or substantial portions of the Software.  	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,	// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES	// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.	// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,	// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTIO	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  		{ // ------------ the global error strings ------------  var errorStrings = {    "geojsonref"              : "http://www.geojson.org/",    "comparewith"             : function(){                                var str =  " Please validate your GeoJson against these specs: "                                 + this.geojsonref;                                 return str;                               },    "nocoordinates"           : "there is no property 'coordinates' in the geometry. ",    "nogeometry"              : "there is no property geometry in your json. ",    "notype"                  : "there is no property 'type' in the geometry. ",    "nofile"                  : "the file is null. Try again. ",    "nogeojson"               : "the geo json is not valid. ",    "featureisolation"        : "The isolation of the geo json features went wrong. ",    "compcreation"            : "There was an error while creating the comp. ",    "noactivecomp"            : "Please select a Composition.",    "diffactviecomptoscale"   : "Your activeItem's size is not conform with you scale factor!"   };mainScript();function mainScript(){	app.beginUndoGroup("Unleash The Geo Beast");	// this will hold all settings and be created by the UI	var meta = {		"ch"                        : 180,		"cw"                        : 360,		"factor"                    : 10,		"dur"                       : 10,		"fps"                       : 25,		"curComp"                   : null,    "compName"                  : "default comp name",		"do3d"                      : true,    "doZorro"                   : true,    "doSinglelayer"             : true,    "intoCurrentComp"           : false,     "createBasicMarker"         : false,    "basicPointMarker"          : null,    "basicPointMarkerName"      : "new Basic Marker",    "bMarkerWidth"              : 25,     "bMarkerHeight"             : 25,    "bMarkerFillColor"          : [0.2,0.2,0.2],    "bMarkerFillTint"           : 50,      "bMarkerStrokeColor"        : [0.9,0.9,0.9],     "separateFeatureTypes"      : false,    "theSLayer"                 : null,    "theSLayerPoly"             : null,    "theSLayerMultiPoly"        : null,    "theSLayerLineString"       : null,    "fitToComp"                 : true,    "nameKey"                   : 'city',     "resetView"                 : false,		"file"                      : null, 		"GEOJSONObject"             : null,		"GeoObjectsList" 		        : null,    /***      *       * point layer types       * 0 is a solid layer      * 1 is a light layer      * 2 is text layer       * 3 is a basic Marker comp // not done yet      * 4 should be solid with text // not done yet      * 5 should be a light with text      * 6 should be a basic marker with text      * 7 ...      *       */     "doPoints"                  : true,		"pointLayerType"		        : 2, 		"doLines" 		              : false,		"lineLayerType"			        : 1,		"doPolygons"                : false,		"polygonLayerType"		      : 0,		"doMultiPolygons"           : false,		"multiPolygonLayerType"     : 0,    "doStroke"                  : true,    "doFill"                    : true,    "fillColor"                 : [1,1,1],    "strokeColor"               : [0,0,0]   	};  // read in the filemeta.file = selectJsonFile();if(meta.file == null){ alert(errorStrings.nofile); return;};meta.compName = meta.file.name;	// read in GEO Datameta.GEOJSONObject = readinGeoJSONFile(meta.file);if(meta.GEOJSONObject == null) {  alert(errorStrings.nogeojson + errorStrings.comparewith());  return;};	// now split it for better handling// the result is an JSON object that has points LineStrings and so onmeta.GeoObjectsList = isolateTypes(meta);if(meta.GeoObjectsList == null){  alert(errorStrings.featureisolation + errorStrings.comparewith());  return; };	/** *  when a ui exists this will go into a separate button *  so the user can edit the marker that will be used for the points *  i will keep it tiny */ if(meta.createBasicMarker == true ){    meta.basicPointMarker = app.project.items.addComp(        meta.basicPointMarkerName,        meta.bMarkerWidth,        meta.bMarkerHeight,        1,        meta.dur,        meta.fps        );    var markerLayer = meta.basicPointMarker.layers.addShape();    markerLayer.name = meta.basicPointMarkerName + " Shape";    var vectorsGroupRoot = markerLayer("ADBE Root Vectors Group");    var vectorGroup = vectorsGroupRoot.addProperty("ADBE Vector Group");    var vectorsGroup = vectorGroup.addProperty("ADBE Vectors Group");    var ellipse = vectorsGroup.addProperty("ADBE Vector Shape - Ellipse");    ellipse.property("ADBE Vector Ellipse Size").setValue([23,23]);    var bMfill = vectorsGroup.addProperty("ADBE Vector Graphic - Fill");    bMfill.property("ADBE Vector Fill Color").setValue(meta.bMarkerFillColor);    bMfill.property("ADBE Vector Fill Opacity").setValue(meta.bMarkerFillTint);        var bMstroke = vectorsGroup.addProperty("ADBE Vector Graphic - Stroke");    bMstroke.property("ADBE Vector Stroke Color").setValue(meta.bMarkerStrokeColor);    bMstroke.property("ADBE Vector Stroke Width").setValue(1);    bMstroke.property("ADBE Vector Stroke Opacity").setValue(meta.bMarkerFillTint);};/** ------------------------------------------------------------------------------------------------ *   *   *   ------------------------------------------------------------------------------------------------ **/// now make the real compif(meta.intoCurrentComp!= true){meta.curComp = app.project.items.addComp(          shortenName(meta.compName),           (meta.cw * meta.factor),           (meta.ch * meta.factor),           1,/*aspect ratio*/          meta.dur,           meta.fps);}else if(meta.intoCurrentComp == true){meta.curComp = app.project.activeItem;    if (!meta.curComp || !(meta.curComp instanceof CompItem)){        alert(errorStrings.noactivecomp);        return;    }  if(meta.curComp.width / meta.factor != 360){    alert(errorStrings.diffactviecomptoscale);  };};if(meta.curComp == null){  alert(errorStrings.compcreation);  return;};  // bring it to the frontif(meta.resetView == true){  resetView(meta.curComp)};                                                         // ------------------------// build the pointsif((meta.doPoints == true)&& (meta.GeoObjectsList.points.length>0)){  drawPoints(meta);}; //end of doPoints// at this point it will create a new shapelayer and set the reference for the functions// if the user chooses to separate the features the refactoriing of the paths will be per layer// if not it will be done for the one shape layer that has all the featuresif((meta.doSinglelayer==true)&&(meta.separateFeatureTypes == false) ){      var newShapeLayer = meta.curComp.layers.addShape();      newShapeLayer.name = "AllGeoObjects";      newShapeLayer.anchorPoint.setValue([meta.curComp.width/2,meta.curComp.height/2]);      meta.theSLayer = newShapeLayer;      meta.theSLayerLineString = meta.theSLayer;      meta.theSLayerPoly = meta.theSLayer;      meta.theSLayerMultiPoly = meta.theSLayer;}// ------------------------// build the lineStringsif((meta.doLines==true) && (meta.GeoObjectsList.lineStrings.length > 0)){  drawLineStrings(meta);}; // end of doLines// ------------------------// build the polygonsif((meta.doPolygons==true)&&(meta.GeoObjectsList.polygons.length > 0)){  drawPolygons(meta);}; // end of doPolygons// ------------------------// build the multipolygons/** *  THIS IS NOT TESTED YET! *   */ if((meta.doMultiPolygons==true) && (meta.GeoObjectsList.multiPolygons.length > 0)){   drawMultiPolygons(meta);}; // end of doMultiPolygons// ------------------------------------------------------------------------------------------------// Now here should start the fitting of the paths// we need a bounding box on the paths and than refactor every pathpoint to a new// location in the comp// the bounding box trick is from nabs repositionAnchorPoints// nice ;)// http://aescripts.com/repositionanchorpoint/if((meta.fitToComp == true ) && ( meta.doSinglelayer == true )){  /**   *     * this works only if we dont draw offscreen   * so meta.resetView has to be true   * these functions are dependend on AE UI functions like   * the new Mask command   * it only makes only sense if we draw all onto one layer   * if they are splited they wont fit together    *   */   if((meta.theSLayer != null) && (meta.separateFeatureTypes == false) && (meta.resetView==true)){       refactorPathsToComp(meta, meta.theSLayer);       repositionAnchor(meta.theSLayer);  };};    alert("I'm done.\nNow its your turn.");    app.endUndoGroup();};/** *  This should write Multipolygons *  Not Tested yet *   */ function drawMultiPolygons (meta) {        if((meta.doSinglelayer==true)&&(meta.separateFeatureTypes ==true)){      meta.theSLayerMultiPoly = meta.curComp.layers.addShape();      meta.theSLayerMultiPoly.name = "AllGeoObjectsMultiPolygon";      meta.theSLayerMultiPoly.anchorPoint.setValue([meta.curComp.width/2,meta.curComp.height/2])    }; // end of doSinglelayer  var closePath = true;  var featureType = 0;  for(var j = 0; j < meta.GeoObjectsList.multiPolygons.length;j++){        var name = meta.GeoObjectsList.multiPolygons[j].name;        if(name.length < 1){          name = "MultiPolygon " + j;        };        var closePath = true;        // alert(meta.GeoObjectsList.multiPolygons[j].coordinates[0].toSource());                // continue;        for(var k = 0; k < meta.GeoObjectsList.multiPolygons[j].coordinates.length;k++){          for(var l = 0; l < meta.GeoObjectsList.multiPolygons[j].coordinates[k].length; l++){                  prepareLayerAndAddPath(                          meta,                           meta.GeoObjectsList.multiPolygons[j],                          name ,                          closePath, 0 ,                          meta.GeoObjectsList.multiPolygons[j].coordinates[k][l],                          meta.theSLayerMultiPoly                          );                };        };      };  //end of i loop lineStrings    if(meta.doSinglelayer == true){      // we add stroke and fill      if(meta.theSLayerMultiPoly instanceof ShapeLayer){          addGraphicProperties(meta,meta.theSLayerMultiPoly,0);        };// end of shapelayercheck    }; // end of single layer stroke creation};/** *  this draws the polygons *   */ function drawPolygons(meta){      if((meta.doSinglelayer==true)&&(meta.separateFeatureTypes== true)){      meta.theSLayerPoly = meta.curComp.layers.addShape();      meta.theSLayerPoly.name = "AllGeoObjectsPolygon";      meta.theSLayerPoly.anchorPoint.setValue([meta.curComp.width/2,meta.curComp.height/2])    }; // end of doSinglelayer  var closePath = true;  var featureType = 0;  for(var j = 0; j < meta.GeoObjectsList.polygons.length;j++){        var name = meta.GeoObjectsList.polygons[j].name;        if(name.length < 1){          name = "Polygon " + j;        };// end of namecheck        var closePath = true;        // alert(meta.GeoObjectsList.polygons[j].coordinates[0].toSource());        // continue;        prepareLayerAndAddPath(                meta,                 meta.GeoObjectsList.polygons[j],                name ,                closePath, 0 ,                meta.GeoObjectsList.polygons[j].coordinates[0],                meta.theSLayerPoly                );      };  //end of j loop polygons    if(meta.doSinglelayer == true){      // we add stroke and fill      if(meta.theSLayerPoly instanceof ShapeLayer){          addGraphicProperties(meta,meta.theSLayerPoly,0);        };// end of shapelayercheck    }; // end of single layer stroke creation};/** *  This draws linestrings *   */ function drawLineStrings(meta){//if we put them onto one single layer we can refactor the whole thing// this means we can create a GEO Object and than fit it to the comp  if((meta.doSinglelayer==true)&&(meta.separateFeatureTypes==true)){    meta.theSLayerLineString = meta.curComp.layers.addShape();    meta.theSLayerLineString.name = "AllGeoObjectsLineString";    meta.theSLayerLineString.anchorPoint.setValue([meta.curComp.width/2,meta.curComp.height/2])  }; // end of doSinglelayerfor(var i = 0; i < meta.GeoObjectsList.lineStrings.length;i++){    var name = meta.GeoObjectsList.lineStrings[i].name;    if(name.length < 1){        name = "LineString " + i;    };    // drawLineStrings(meta, meta.GeoObjectsList.lineStrings[i], name);    var closePath = false;    // alert(meta.GeoObjectsList.lineStrings[i].coordinates.toSource());    prepareLayerAndAddPath(            meta,            meta.GeoObjectsList.lineStrings[i],            name,            closePath, 1,            meta.GeoObjectsList.lineStrings[i].coordinates,            meta.theSLayerLineString            );  };  //end of i loop lineStrings  if(meta.doSinglelayer == true){    // we add a stroke and no fill    if(meta.theSLayerLineString instanceof ShapeLayer){      var stroke = meta.theSLayerLineString("ADBE Root Vectors Group").addProperty("ADBE Vector Graphic - Stroke");      stroke.name = "stroke";    };  }; // end of single layer stroke creation};/** *  this prepares a layer for adding a path *  it works for lineStrings,polygons and multipolygons */ function prepareLayerAndAddPath(meta, geojsonObject, name ,closePath, featureType, coordinates,layer){var newLayer = null;if(meta.doSinglelayer != true){  if(meta.lineLayerType == 0){    newLayer = meta.curComp.layers.addSolid(                [1,1,1],                name ,                 meta.curComp.width, meta.curComp.height, 1,                 meta.curComp.duration);  }else if(meta.lineLayerType == 1 ){    newLayer = meta.curComp.layers.addShape();    newLayer.name = name;    newLayer.anchorPoint.setValue([meta.curComp.width/2,meta.curComp.height/2]);  };}else if (meta.doSinglelayer==true){newLayer = layer;};    if(meta.doZorro==true){      addZorroComment(newLayer, name);    };// end doZorro  // alert(lineString.toSource());  // featureType 0 adds a fill featureType 1 adds a stroke  addPath(meta, newLayer, coordinates, closePath, name, featureType);};// ------------ end of prepareLayerAndAddPath ------------/** * adds a path to a layer  * parts taken from http://www.redefinery.com/ae/fundamentals/masks/ * great resource© * edited to use also shapelayers */ function addPath(meta, layer, path ,closePath, name ,type){  // alert(path.toSource());  pt = new Array();  for(var j =0; j < path.length;j++){    var x = (path[j][0])* meta.factor + (meta.curComp.width/2);    var y = (path[j][1]* -1)* meta.factor + (meta.curComp.height/2);    // in here the bounding box should be calculated    pt.push([x,y]);  }; // close coords loop  var masksGroup = null;if( layer instanceof ShapeLayer ){  masksGroup = layer("ADBE Root Vectors Group"); // Get the PropertyGroup for the shape  }else {  masksGroup = layer("ADBE Mask Parade"); // Get the PropertyGroup for the masks};if (masksGroup != null){  var mask = null;  var shapeGroup = null;  if(layer instanceof ShapeLayer){    mask = masksGroup.addProperty("ADBE Vector Shape - Group");  }else {    mask = masksGroup.addProperty("ADBE Mask Atom");       // Create a new mask  };    if (mask != null){      mask.name = name;    var s = new Shape();// new shape object    if (s != null){            s.vertices = pt;                        // put the path verticies into the shape            s.closed = closePath;                        // The close attribute defaults to true             if(layer instanceof ShapeLayer){            maskShape = mask.property("ADBE Vector Shape");            }else {               maskShape = mask.property("ADBE Mask Shape");  // Get the Mask Shape property for the mask            };            maskShape.setValue(s);                   // Change the mask shape (not keyframed)        };    };    /**     * We need to add a fill and a stroke     * here if we du multiple layers      *       */     if((meta.doSinglelayer == false)){      addGraphicProperties(meta,layer,type);    };    // ------------------------  };};/** *  Adds a zorro comment *   */  function addZorroComment(layer,comment){  comment = comment.replace(/[^a-z0-9_\-]/gi, '_');    if(layer.comment.length > 1){      layer.comment = layer.comment + ",*"+comment;    }else{      layer.comment = "*"+comment;    };     };/** *  adds a stroke and fill *   */ function addGraphicProperties(meta, layer,type){        if(meta.doStroke == true){          var stroke = layer("ADBE Root Vectors Group").addProperty("ADBE Vector Graphic - Stroke");          stroke.property("ADBE Vector Stroke Color").setValue(meta.strokeColor);          stroke.name = "stroke";          };// end of doStroke          if((meta.doFill == true)&&(type != 1)){          var fill = layer("ADBE Root Vectors Group").addProperty("ADBE Vector Graphic - Fill");          fill.property("ADBE Vector Fill Color").setValue(meta.fillColor);          fill.name = "fill";          };// end of doFill};  //  _____   ____ _____ _   _ _______   // |  __ \ / __ \_   _| \ | |__   __|  // | |__) | |  | || | |  \| |  | |     // |  ___/| |  | || | | . ` |  | |     // | |    | |__| || |_| |\  |  | |     // |_|     \____/_____|_| \_|  |_|     //  _____  _____       __          _______ _   _  _____   // |  __ \|  __ \     /\ \        / /_   _| \ | |/ ____|  // | |  | | |__) |   /  \ \  /\  / /  | | |  \| | |  __   // | |  | |  _  /   / /\ \ \/  \/ /   | | | . ` | | |_ |  // | |__| | | \ \  / ____ \  /\  /   _| |_| |\  | |__| |  // |_____/|_|  \_\/_/    \_\/  \/   |_____|_| \_|\_____|                                                                                                              /** *  This draws points *  This is diffrent than drawing lines *  it creates null objects lights or text from a key given by the user *  This means we can do cities *  points can be 3D *  ------------------------ *  i want to add some other layer types like *  * project selected comp or AVLayer *  * basic marker *  * or the script creates a basic marker on a button an the user can change it */ function drawPoints(meta) {  for(var i = 0; i < meta.GeoObjectsList.points.length;i++){    var name = meta.GeoObjectsList.points[i].name;    if(name.length < 1){      name = "Point " + i;    };    var point = meta.GeoObjectsList.points[i];    var position = point.coordinates;    var x = (position[0]) * meta.factor + ( meta.curComp.width / 2);    var y = (position[1]*-1) * meta.factor + ( meta.curComp.height / 2);    var newLayer =  null;    if(meta.pointLayerType == 0){      newLayer = meta.curComp.layers.addSolid([1,1,1], name , 13, 13, 1, meta.curComp.duration);    } else if (meta.pointLayerType == 1 ){      newLayer = meta.curComp.layers.addLight(name,[x,y]);    }else if(meta.pointLayerType == 2 ){      newLayer = meta.curComp.layers.addText(name);    }else if (meta.pointLayerType == 3){      newLayer = meta.curComp.layers.add(meta.basicPointMarker);      newLayer.name = name;    };    if(meta.do3d == true){      newLayer.threeDLayer = true;    };    if(meta.doZorro==true){      addZorroComment(newLayer,name);    };    if(meta.pointLayerType != 1){       setLayerPosition(meta.do3d , newLayer ,x,y);    };  };// end of i loop points};function setLayerPosition(do3d, layer, x, y ){    // thanx redifinery http://www.redefinery.com/ae/fundamentals/layers/    if((do3d == true) || (layer instanceof LightLayer) ){      layer.position.setValue ([x,y,0]);      }else{      layer.position.setValue ([x,y]);    };};// ------------ utilities ------------  function shortenName(str) {    var res = "";    if (parseFloat(app.version) < 10.0) {      res = str.substr(0, 26);    } else {      res = str;    };    return res;  };/** *  this resets the view  * */   function resetView(comp){    var duration = comp.workAreaDuration;    comp.workAreaDuration = (1 / comp.frameRate) * 5; // ae needs at least 2 frames for previewing     comp.ramPreviewTest(1.0, 1.0, 0); // i think this is where the CS4 Problems start     comp.workAreaDuration = duration;    comp.resolutionFactor = [4, 4];  };// ------------ FILE HANDLING ------------function selectJsonFile(){        var jsonfile = File.openDialog("Select a jsonfile", "*.json", false);        if (jsonfile != null) {         return jsonfile;        } else {          // alert("Error file is null");		      return null;        };};  function readinGeoJSONFile(theFile) {    // var textFile = File.openDialog("Select a text file to import.", "*.*",false);    // var path = ((new File($.fileName)).path);    var textFile = theFile; //;File( path+"/world_geo_json/" + THESELECTEDFILE);    if (textFile != null) {      var textLines = new Array();      textFile.open("r", "TEXT", "????");      while (!textFile.eof) {        textLines[textLines.length] = textFile.readln();      };      textFile.close();    };    if (!textLines) {      alert("there are no lines in your file or something went terribly wrong.");      return;    };    var str = textLines.join("");    var reg = new RegExp("\n|\r", "g");    str.replace(reg, " ");    // alert(str);    // normaly this should not use eval    // but i dont want to incorporate the JSON lib    var obj = eval("(" + str + ")"); // evaluate the JSON code    // if(obj === Object){alert("eval worked")}else{alert("eval error")};    return obj;  };// ------------ end of file handling ------------  //       _  _____  ____  _   _   //      | |/ ____|/ __ \| \ | |  //      | | (___ | |  | |  \| |  //  _   | |\___ \| |  | | . ` |  // | |__| |____) | |__| | |\  |  //  \____/|_____/ \____/|_| \_|/** *  GEO JSON handling it has to look into it and find properties *  and coordiantes and so *   *   */ /** *  isolate the diffrent types of feature collection or *  simple features than it sends the result into  *  getLocationsByType()   */ function isolateTypes(meta){	// var GEOJSONObject = meta.GEOJSONObject;	var features = meta.GEOJSONObject.features;      var GeoObjectsList = {      		"points": [],      		"lineStrings" :[],      		"polygons" : [],      		"multiPolygons": []       };    for (var i in features) {      var geometry = features[i].geometry;      // alert(geometry.toSource());      if (geometry != null) {        var patternGC = "GeometryCollection";        regGC = new RegExp(patternGC);        var type = geometry.type;        if (regGC.test(type) == true) {          	// alert("GM COLL");          	var geometries = geometry.geometries;          	for (var j = 0; j < geometries.length; j++) {            getLocationsByType(meta,features[i],meta.nameKey, geometries[j], GeoObjectsList);          }; // close J LOOP        /* CLOSE REG TEST FOR GMCollection */         } else {        // this is simple geometry no geometry collection         getLocationsByType(meta,features[i],meta.nameKey, geometry,  GeoObjectsList);        }; // test for collection      }else{      	alert(errorStrings.nogeometry);      }; // geometry is not null    }; // end of i loopreturn GeoObjectsList;};/** * this function separates the features from the GEOJson * for better handling  * it also finds a property by a defined key *    arguments: * meta is the mta master object * feature is one object * nameKey is the string to look for in the properties * geometry is the features gemotry *    return: * it just sets some data into the meta object * there is no return */   function getLocationsByType(meta,feature, nameKey, geometry , GeoObjectList) {    var coords = null;    /**      * first we check for a property that holds our text     * this is pretty cool because the user can define a key     * and the function selects by that key     * the trick is the for key in feature     * key is than the name not a number     * have a look at this stackoverflow     * http://stackoverflow.com/questions/4222596/json-get-key-names-as-text     *      */         var name = "";    if (feature.hasOwnProperty('properties')) {      if(feature.properties.hasOwnProperty(nameKey)){        for(var key in feature.properties){            pattern = nameKey;          var regKey = new RegExp(pattern, "g");          if (regKey.test(key)     == true) {            name = feature.properties[key];          };        };              };    }; // end of feature.hasOwnProperty('properties') // ------------ now lets dig for coordinates ------------    if (geometry.hasOwnProperty("coordinates")) {      if(geometry.hasOwnProperty("type")){           var type = geometry.type;           var pattern = "";        // if(geometry.hasOwnProperty("coordinates")){        // ------------ CHECK 4 POINTS ------------          if((meta.doPoints)){                  pattern = "Point";              var regPnt = new RegExp(pattern, "g");              if (regPnt.test(type)    == true) {                coords = geometry.coordinates;                GeoObjectList.points.push({"name":name ,"coordinates":coords});                  }; // end POINT}        };// end of checkForPoints dont draw            // ------------ CHECK 4 LINSTRINGs ------------        if(meta.doLines){              pattern = "LineString";              var regLn = new RegExp(pattern, "g");              if (regLn.test(type)     == true) {                coords = geometry.coordinates;                GeoObjectList.lineStrings.push({"name":name ,"coordinates":coords});                  }; // end LINESTRING        };// end of checkForLines dont draw            // ------------ CHECK 4 POLYGON ------------        if(meta.doPolygons){              pattern = "^Polygon";              var regPol = new RegExp(pattern, "g");              if (regPol.test(type)    == true)  {                coords = geometry.coordinates;                GeoObjectList.polygons.push({"name":name ,"coordinates":coords});                  }; //end POLYGON        };// end end of ckeckForPolys dont draw            // ------------ CHECK 4 MULTIPOLYGON ------------        if( meta.doMultiPolygons){              pattern = "MultiPolygon";              var regMPol = new RegExp(pattern, "g");              if (regMPol.test(type)   == true) {              coords = geometry.coordinates;              GeoObjectList.multiPolygons.push({"name":name ,"coordinates":coords});              }; //end MULTIPOLYGON          };// end endOfCheckForMultiPolys dont draw          }else{            alert(errorStrings.notype);          };                }else{          alert(errorStrings.nocoordinates);        };    //   } else {    //   alert(errorStrings.nogeometry);    // };    pattern = "";  };/** *  From here on are functions that depend on AE UI options *  they cant be used offscreen *  its a lot of path handling an bounding box and so *   */ function refactorPathsToComp(meta, layer){    var scalar = 1;    // var scalarX = 1;    // var scalarY = 1;    var bBox = calcBBoxOflayer(layer);    if (bBox!= null){      alert("x: " + bBox.xoffset + " y: " + bBox.yoffset);       // return;    var scalarX = meta.curComp.width / bBox.width;    var scalarY = meta.curComp.height / bBox.height;      // calc the scalar      if(bBox.width > bBox.height){        scalar = meta.curComp.width / bBox.width;      }else if(bBox.width < bBox.height ){        scalar = meta.curComp.height / bBox.height;      }else if (bBox.width == bBox.height){        scalar = meta.curComp.width / bBox.width;      };      // alert(scalar);      var rootVectorGroup = layer.property("ADBE Root Vectors Group");      // alert(layer.property("ADBE Root Vectors Group").numProperties);      for(var i =1; i <= rootVectorGroup.numProperties ; i++){          // alert(rootVectorGroup.property(i));        var pat = "stroke|fill";        var reg = new RegExp(pat,"g");        if (reg.test(rootVectorGroup.property(i).name) != true) {          var verts = rootVectorGroup.property(i).property("ADBE Vector Shape").value.vertices;          var refactoredShape = new Shape();          var pt = new Array();          for(var j = 0; j < verts.length; j++){             var x = (verts[j][0] - bBox.xoffset) * scalarY;             var y = (verts[j][1] - bBox.yoffset) * scalarX;             pt.push([x,y]);          };          refactoredShape.vertices = pt;          // alert(refactoredShape.vertices);          rootVectorGroup.property(i).property("ADBE Vector Shape").setValue(refactoredShape);              };    };  };};// ------------------------------------------------------------------------------------------------ //  _____  ______ _____   ____   _____ _____ _______ ____  _   _  // |  __ \|  ____|  __ \ / __ \ / ____|_   _|__   __/ __ \| \ | | // | |__) | |__  | |__) | |  | | (___   | |    | | | |  | |  \| | // |  _  /|  __| |  ___/| |  | |\___ \  | |    | | | |  | | . ` | // | | \ \| |____| |    | |__| |____) |_| |_   | | | |__| | |\  | // |_|  \_\______|_|     \____/|_____/|_____|  |_|  \____/|_| \_| //           _   _  _____ _    _  ____  _____   //     /\   | \ | |/ ____| |  | |/ __ \|  __ \  //    /  \  |  \| | |    | |__| | |  | | |__) | //   / /\ \ | . ` | |    |  __  | |  | |  _  /  //  / ____ \| |\  | |____| |  | | |__| | | \ \  // /_/    \_\_| \_|\_____|_|  |_|\____/|_|  \_\  // this part is taken from the following script                                              // many thanx - great resource // i never could have written that myself! // thank you thank you thank you // Name: //  RepositionAnchorPoint // Version: //  3.3 (2 Nov 2011) by Lloyd Alvarez // Author: //  Charles Bordenave // a bit rewritten for my needs // have a look at the original // http://aescripts.com/repositionanchorpoint/ // the option to calc the BBox from a mask layer is deacivated right knowfunction repositionAnchor(layer){        var bBox = calcBBoxOflayer(layer);    if (bBox){        var anchPt = layer.anchorPoint;        var pos = layer.position;                       var halfW = bBox.width / 2;        var halfH = bBox.height / 2;        var xoffset = bBox.xoffset;        var yoffset = bBox.yoffset;                // Apply expressions                anchPt.expression =         "fromWorld(toWorld([" + halfW + "," + halfH + ",0] + [0 *" + halfW + "+" + xoffset + ", 0 *"+ halfH + "+" + yoffset + ",0]));";                pos.expression =        "try {\r" +          " parent.fromWorld(toWorld([" + halfW + "," + halfH + ",0] + [0 *" + halfW + "+" + xoffset + ",0 *"+ halfH + "+" + yoffset + ",0]));\r" +        "}\r" +        "catch(e)\r" +        "{\r" +         "  toWorld([" + halfW + "," + halfH + ",0] + [0 *" + halfW + "+" + xoffset + ",0 *"+ halfH + "+" + yoffset + ",0]);\r" +        "}";                             // Little refreshing trick        pos.expressionEnabled = false;        pos.expressionEnabled = true;                var anchPtVal = anchPt.valueAtTime(0, false);        anchPt.expression = "";                var posVal = pos.valueAtTime(0, false);        pos.expression = "";                // Set value        anchPt.numKeys ? anchPt.setValueAtTime(0, anchPtVal) : anchPt.setValue(anchPtVal);        pos.numKeys ? pos.setValueAtTime(0, posVal) : pos.setValue(posVal);                                 };    };// the bounding box is dependend on the layer center and anchor// function BBox (w,h,xoff,yoff) {    this.width = w;    this.height = h;    this.xoffset = xoff;    this.yoffset = yoff;};/** * This is pretty deep shit. I bow my head * I mean the trick with the new mask on the Shape Layers is already sweet * and the vertex checking with min4 and max4... wow! i mean WOW. */function calcBBoxOflayer(layer){var bbox = null;if(layer instanceof ShapeLayer){layer.selected = true;  app.executeCommand(2367); // 2367 : app.findMenuCommandId("New Mask")  var mask = layer.Masks.property(layer.Masks.numProperties);  var verts = mask.maskShape.value.vertices;  mask.remove();  bbox = new BBox (Math.abs(verts[0][0] - verts[3][0]),Math.abs(verts[0][1] - verts[1][1]),verts[0][0],verts[0][1]);   return bbox;    }//     else{// var maskGrp = layer.Masks;// var bBox = null;// if (maskGrp.numProperties){//         var T = Infinity;//         var B = -Infinity;//         var L = Infinity;//         var R = -Infinity;          //         for (var m = 1; m <= maskGrp.numProperties; m++){//           var mask = maskGrp.property(m);//           var maskShape = mask.maskShape;            //           var shape = maskShape.valueAtTime(0, false);//           var verts = shape.vertices;//           var intan = shape.inTangents;//           var outtan = shape.outTangents;//           for (var i = 0; i < verts.length; i++){//             T = min4(T, verts[i][1], verts[i][1]+intan[i][1], verts[i][1]+outtan[i][1]);//             B = max4(B, verts[i][1], verts[i][1]+intan[i][1], verts[i][1]+outtan[i][1]);//             L = min4(L, verts[i][0], verts[i][0]+intan[i][0], verts[i][0]+outtan[i][0]);//             R = max4(R, verts[i][0], verts[i][0]+intan[i][0], verts[i][0]+outtan[i][0]);//           };// close i loop//           }; //close m loop//         bBox = new BBox(R-L,B-T,L,T);//       }; // close maskGrp.numPropeertiws        //        return bBox;//     };// close else};function min4 (n1, n2, n3, n4)  {    return (n1 < n2 && n1 < n3 && n1 < n4) ? n1 :         ((n2 < n1 && n2 < n3 && n2 < n4) ? n2 :        ((n3 < n1 && n3 < n2 && n3 < n4) ? n3 : n4));             };   // Computes the maximum value between four numbersfunction max4(n1, n2, n3, n4)  {    return (n1 > n2 && n1 > n3 && n1 > n4) ? n1 :         ((n2 > n1 && n2 > n3 && n2 > n4) ? n2 :        ((n3 > n1 && n3 > n2 && n3 > n4) ? n3 : n4));             };// ------------------------------------------------------------------------------------------------  //END SCRIPT}